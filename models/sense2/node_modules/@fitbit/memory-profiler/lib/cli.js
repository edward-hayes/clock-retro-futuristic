"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs = require("fs");
const graphology_gexf_1 = require("graphology-gexf");
const AppPackage = require("@fitbit/app-package");
const JSZip = require("jszip");
const yargs = require("yargs");
const convert_1 = require("./convert");
const repl = require("node:repl");
const util = require("node:util");
var OutputFormat;
(function (OutputFormat) {
    OutputFormat[OutputFormat["V8"] = 0] = "V8";
    OutputFormat[OutputFormat["GEXF"] = 1] = "GEXF";
})(OutputFormat || (OutputFormat = {}));
function makeGraph(snapshotPath, fbaPath, deviceType) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const fbaData = fs.readFileSync(fbaPath);
        const fbaZip = yield JSZip.loadAsync(fbaData);
        const fba = yield AppPackage.fromJSZip(fbaZip);
        const snapshotBuffer = fs.readFileSync(snapshotPath);
        if (!fba.sourceMaps ||
            !fba.sourceMaps.device ||
            !fba.sourceMaps.device[deviceType]) {
            throw new Error('Provided FBA file does not contain sourcemaps for requested device type!');
        }
        const graph = yield (0, convert_1.generateGraph)(snapshotBuffer, 'jerryscript-1', fba.sourceMaps.device[deviceType]);
        return graph;
    });
}
function convertCommand(snapshotPath, fbaPath, outputPath, deviceType, outputFormat) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const graph = yield makeGraph(snapshotPath, fbaPath, deviceType);
        let out;
        if (outputFormat === OutputFormat.V8) {
            const convertedSnapshot = (0, convert_1.generateV8HeapSnapshot)(graph);
            out = JSON.stringify(convertedSnapshot);
        }
        else if (outputFormat === OutputFormat.GEXF) {
            out = (0, graphology_gexf_1.write)(graph);
        }
        else {
            throw new Error('Unknown output format');
        }
        fs.writeFileSync(outputPath, out);
    });
}
function startRepl(snapshotPath, fbaPath, deviceType) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const graph = yield makeGraph(snapshotPath, fbaPath, deviceType);
        process.stdout.write('The graph is available as `g` and root nodes as `roots`.\n\nThe API is documented at https://graphology.github.io/.\n');
        const r = repl.start({
            prompt: '> ',
            writer: (o) => util.inspect(o, { maxArrayLength: Infinity }),
        });
        r.context.g = graph;
        r.context.roots = graph.filterNodes((n) => graph.inEdges(n).length === 0 && graph.outEdges(n).length > 0);
    });
}
const builder = (args) => args
    .positional('snapshot', {
    description: 'Heap snapshot path',
    type: 'string',
    demandOption: true,
})
    .positional('fba', {
    description: 'FBA file path',
    type: 'string',
    demandOption: true,
})
    .positional('output', {
    description: 'Output heap data file path',
    type: 'string',
    demandOption: true,
})
    .positional('deviceType', {
    description: 'Device type',
    type: 'string',
    demandOption: true,
});
const cmd = (args, outFormat) => convertCommand(args.snapshot, args.fba, args.output, args.deviceType, outFormat).catch((error) => {
    process.exitCode = 1;
    if (error)
        console.error(error);
});
yargs
    .command('v8 <snapshot> <fba> <output> <deviceType>', 'Convert heap snapshot to v8 heap snapshot', builder, (args) => {
    return cmd(args, OutputFormat.V8);
})
    .command('gexf <snapshot> <fba> <output> <deviceType>', 'Convert heap snapshot to a GEXF graph', builder, (args) => {
    return cmd(args, OutputFormat.GEXF);
})
    .command('repl <snapshot> <fba> <deviceType>', 'Start a Node REPL to explore the heap graph', (args) => args
    .positional('snapshot', {
    description: 'Heap snapshot path',
    type: 'string',
    demandOption: true,
})
    .positional('fba', {
    description: 'FBA file path',
    type: 'string',
    demandOption: true,
})
    .positional('deviceType', {
    description: 'Device type',
    type: 'string',
    demandOption: true,
}), (args) => {
    startRepl(args.snapshot, args.fba, args.deviceType);
})
    .demandCommand()
    .help().argv;
//# sourceMappingURL=cli.js.map