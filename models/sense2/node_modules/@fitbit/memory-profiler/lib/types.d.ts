import * as t from 'io-ts';
import { FDBTypes } from '@fitbit/fdb-protocol';
export declare const NodeTypes: t.UnionC<[t.LiteralC<"Hidden">, t.LiteralC<"Array">, t.LiteralC<"String">, t.LiteralC<"Object">, t.LiteralC<"Code">, t.LiteralC<"Sourcemap">, t.LiteralC<"Closure">, t.LiteralC<"Regexp">, t.LiteralC<"Heapnumber">, t.LiteralC<"Native">, t.LiteralC<"Synthetic">, t.LiteralC<"Constring">, t.LiteralC<"Slicedstring">, t.LiteralC<"Symbol">, t.LiteralC<"Bigint">]>;
export declare const v8NodeTypes: Map<"Hidden" | "Array" | "String" | "Object" | "Code" | "Sourcemap" | "Closure" | "Regexp" | "Heapnumber" | "Native" | "Synthetic" | "Constring" | "Slicedstring" | "Symbol" | "Bigint", string>;
export declare const EdgeTypes: t.UnionC<[t.LiteralC<"hidden">, t.LiteralC<"lexenv">, t.LiteralC<"prototype">, t.LiteralC<"bind">, t.LiteralC<"this">, t.LiteralC<"bindargs">, t.LiteralC<"element">, t.LiteralC<"property">, t.LiteralC<"propertyname">, t.LiteralC<"propertyget">, t.LiteralC<"propertyset">, t.LiteralC<"promiseresult">, t.LiteralC<"promisefulfill">, t.LiteralC<"promisereject">, t.LiteralC<"scope">, t.LiteralC<"shortcut">, t.LiteralC<"weak">]>;
export declare const NodeFields: t.UnionC<[t.LiteralC<"id">, t.LiteralC<"size">, t.LiteralC<"repr">]>;
export declare const EdgeFields: t.UnionC<[t.LiteralC<"from">, t.LiteralC<"to">, t.LiteralC<"name">]>;
export declare type EdgeFields = t.TypeOf<typeof EdgeFields>;
export declare const HeapSnapshot: t.TypeC<{
    meta: t.TypeC<{
        types: t.ArrayC<t.UnionC<[t.UnionC<[t.LiteralC<"Hidden">, t.LiteralC<"Array">, t.LiteralC<"String">, t.LiteralC<"Object">, t.LiteralC<"Code">, t.LiteralC<"Sourcemap">, t.LiteralC<"Closure">, t.LiteralC<"Regexp">, t.LiteralC<"Heapnumber">, t.LiteralC<"Native">, t.LiteralC<"Synthetic">, t.LiteralC<"Constring">, t.LiteralC<"Slicedstring">, t.LiteralC<"Symbol">, t.LiteralC<"Bigint">]>, t.UnionC<[t.LiteralC<"hidden">, t.LiteralC<"lexenv">, t.LiteralC<"prototype">, t.LiteralC<"bind">, t.LiteralC<"this">, t.LiteralC<"bindargs">, t.LiteralC<"element">, t.LiteralC<"property">, t.LiteralC<"propertyname">, t.LiteralC<"propertyget">, t.LiteralC<"propertyset">, t.LiteralC<"promiseresult">, t.LiteralC<"promisefulfill">, t.LiteralC<"promisereject">, t.LiteralC<"scope">, t.LiteralC<"shortcut">, t.LiteralC<"weak">]>]>>;
        nodeFields: t.ArrayC<t.UnionC<[t.LiteralC<"id">, t.LiteralC<"size">, t.LiteralC<"repr">]>>;
        edgeFields: t.ArrayC<t.UnionC<[t.LiteralC<"from">, t.LiteralC<"to">, t.LiteralC<"name">]>>;
    }>;
    items: t.AnyC;
}>;
export declare type HeapSnapshot = t.TypeOf<typeof HeapSnapshot>;
export declare const RawPosition: t.UnionC<[t.StringC, t.TupleC<[t.UnionC<[t.NumberC, t.StringC]>, t.NumberC, t.NumberC, t.UnionC<[t.NullC, t.StringC]>]>, t.NullC]>;
export declare type RawPosition = t.TypeOf<typeof RawPosition>;
export declare const RawNode: t.TypeC<{
    type: t.UnionC<[t.LiteralC<"Hidden">, t.LiteralC<"Array">, t.LiteralC<"String">, t.LiteralC<"Object">, t.LiteralC<"Code">, t.LiteralC<"Sourcemap">, t.LiteralC<"Closure">, t.LiteralC<"Regexp">, t.LiteralC<"Heapnumber">, t.LiteralC<"Native">, t.LiteralC<"Synthetic">, t.LiteralC<"Constring">, t.LiteralC<"Slicedstring">, t.LiteralC<"Symbol">, t.LiteralC<"Bigint">]>;
    id: t.NumberC;
    size: t.UnionC<[t.NumberC, t.NullC]>;
    repr: t.UnionC<[t.StringC, t.TupleC<[t.UnionC<[t.NumberC, t.StringC]>, t.NumberC, t.NumberC, t.UnionC<[t.NullC, t.StringC]>]>, t.NullC]>;
}>;
export declare type RawNode = t.TypeOf<typeof RawNode>;
export declare const Node: t.IntersectionC<[t.TypeC<{
    type: t.UnionC<[t.LiteralC<"Hidden">, t.LiteralC<"Array">, t.LiteralC<"String">, t.LiteralC<"Object">, t.LiteralC<"Code">, t.LiteralC<"Sourcemap">, t.LiteralC<"Closure">, t.LiteralC<"Regexp">, t.LiteralC<"Heapnumber">, t.LiteralC<"Native">, t.LiteralC<"Synthetic">, t.LiteralC<"Constring">, t.LiteralC<"Slicedstring">, t.LiteralC<"Symbol">, t.LiteralC<"Bigint">]>;
    id: t.NumberC;
    size: t.UnionC<[t.NumberC, t.NullC]>;
}>, t.UnionC<[t.TypeC<{
    position: t.IntersectionC<[t.TypeC<{
        source: t.RefinementC<t.StringC>;
        line: t.RefinementC<t.RefinementC<t.NumberC>>;
        column: t.RefinementC<t.RefinementC<t.NumberC>>;
    }>, t.PartialC<{
        generated: t.BooleanC;
        name: t.StringC;
    }>]>;
}>, t.PartialC<{
    repr: t.StringC;
}>]>]>;
export declare type Node = t.TypeOf<typeof Node>;
export declare type SourcePosition = t.TypeOf<typeof FDBTypes.Position>;
export declare const Edge: t.IntersectionC<[t.TypeC<{
    type: t.UnionC<[t.LiteralC<"hidden">, t.LiteralC<"lexenv">, t.LiteralC<"prototype">, t.LiteralC<"bind">, t.LiteralC<"this">, t.LiteralC<"bindargs">, t.LiteralC<"element">, t.LiteralC<"property">, t.LiteralC<"propertyname">, t.LiteralC<"propertyget">, t.LiteralC<"propertyset">, t.LiteralC<"promiseresult">, t.LiteralC<"promisefulfill">, t.LiteralC<"promisereject">, t.LiteralC<"scope">, t.LiteralC<"shortcut">, t.LiteralC<"weak">]>;
    to: t.NumberC;
    from: t.NumberC;
}>, t.PartialC<{
    name: t.StringC;
}>]>;
export declare type Edge = t.TypeOf<typeof Edge>;
export declare const RawEdge: t.TypeC<{
    type: t.UnionC<[t.LiteralC<"hidden">, t.LiteralC<"lexenv">, t.LiteralC<"prototype">, t.LiteralC<"bind">, t.LiteralC<"this">, t.LiteralC<"bindargs">, t.LiteralC<"element">, t.LiteralC<"property">, t.LiteralC<"propertyname">, t.LiteralC<"propertyget">, t.LiteralC<"propertyset">, t.LiteralC<"promiseresult">, t.LiteralC<"promisefulfill">, t.LiteralC<"promisereject">, t.LiteralC<"scope">, t.LiteralC<"shortcut">, t.LiteralC<"weak">]>;
    to: t.NumberC;
    from: t.NumberC;
    name: t.UnionC<[t.NumberC, t.StringC, t.NullC]>;
}>;
export declare type RawEdge = t.TypeOf<typeof RawEdge>;
export interface GraphNodeAttributes {
    name: string;
    type: t.TypeOf<typeof NodeTypes>;
    memory_size: number | null;
}
export interface GraphEdgeAttributes {
    name: string | null;
    type: t.TypeOf<typeof EdgeTypes>;
}
export declare type ChromeDevNode = [
    typ: t.TypeOf<typeof NodeTypes>,
    name: string,
    id: number,
    self_size: number,
    edge_count: number,
    trace_node_id: 0,
    detachedness: 0
];
export declare type ChromeDevEdge = [
    typ: t.TypeOf<typeof EdgeTypes>,
    name_or_index: string | number,
    to_node: number
];
export declare const nodeTypeMap: Map<"Hidden" | "Array" | "String" | "Object" | "Code" | "Sourcemap" | "Closure" | "Regexp" | "Heapnumber" | "Native" | "Synthetic" | "Constring" | "Slicedstring" | "Symbol" | "Bigint", number>;
export declare const nodeTypeList: ("Hidden" | "Array" | "String" | "Object" | "Code" | "Sourcemap" | "Closure" | "Regexp" | "Heapnumber" | "Native" | "Synthetic" | "Constring" | "Slicedstring" | "Symbol" | "Bigint")[];
declare type NodeTypeList = typeof nodeTypeList;
export declare const edgeTypeMap: Map<"hidden" | "lexenv" | "prototype" | "bind" | "this" | "bindargs" | "element" | "property" | "propertyname" | "propertyget" | "propertyset" | "promiseresult" | "promisefulfill" | "promisereject" | "scope" | "shortcut" | "weak", number>;
export declare const edgeTypeList: ("hidden" | "lexenv" | "prototype" | "bind" | "this" | "bindargs" | "element" | "property" | "propertyname" | "propertyget" | "propertyset" | "promiseresult" | "promisefulfill" | "promisereject" | "scope" | "shortcut" | "weak")[];
declare type EdgeTypeList = typeof edgeTypeList;
export interface V8HeapSnapshot {
    snapshot: {
        meta: {
            node_fields: string[];
            node_types: [type_types: NodeTypeList, ...other_field_types: string[]];
            edge_fields: string[];
            edge_types: [type_types: EdgeTypeList, ...other_field_types: string[]];
            location_fields?: string[];
        };
        node_count: number;
        edge_count: number;
        trace_function_count: 0;
    };
    nodes: number[];
    edges: number[];
    locations?: number[];
    strings: string[];
}
export {};
//# sourceMappingURL=types.d.ts.map