"use strict";
var _StringMapper_nextIdx, _StringMapper_lookup;
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateV8HeapSnapshot = exports.generateGraph = void 0;
const tslib_1 = require("tslib");
const path = require("path");
const cbor = require("cbor");
const PathReporter_1 = require("io-ts/lib/PathReporter");
const pipeable_1 = require("fp-ts/lib/pipeable");
const Either_1 = require("fp-ts/lib/Either");
const lodash = require("lodash");
const source_map_1 = require("source-map");
const types_1 = require("./types");
const assert = require("assert");
const graphology_1 = require("graphology");
class StringMapper {
    constructor() {
        _StringMapper_nextIdx.set(this, 0);
        _StringMapper_lookup.set(this, new Map());
    }
    addString(s) {
        if (!tslib_1.__classPrivateFieldGet(this, _StringMapper_lookup, "f").has(s)) {
            tslib_1.__classPrivateFieldGet(this, _StringMapper_lookup, "f").set(s, tslib_1.__classPrivateFieldGet(this, _StringMapper_nextIdx, "f"));
            tslib_1.__classPrivateFieldSet(this, _StringMapper_nextIdx, tslib_1.__classPrivateFieldGet(this, _StringMapper_nextIdx, "f") + 1, "f");
        }
        return tslib_1.__classPrivateFieldGet(this, _StringMapper_lookup, "f").get(s);
    }
    get stringsArray() {
        return [...tslib_1.__classPrivateFieldGet(this, _StringMapper_lookup, "f").keys()];
    }
}
_StringMapper_nextIdx = new WeakMap(), _StringMapper_lookup = new WeakMap();
const mapValues = (obj, mapper) => Promise.all(Object.entries(obj).map(([key, value], index) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return ({
        [key]: yield mapper(value, key, index),
    });
}))).then((entries) => entries.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {}));
function validateOrThrow(type, data) {
    return (0, pipeable_1.pipe)(type.decode(data), (0, Either_1.fold)((errors) => {
        throw new Error((0, PathReporter_1.failure)(errors).join('\n'));
    }, (validatedData) => validatedData));
}
function normalizeRawNode({ id, type, size, repr }, rawNodes) {
    if (Array.isArray(repr)) {
        const [source, line, column, name] = repr;
        return {
            id,
            type,
            size,
            position: {
                line,
                column,
                name: name || undefined,
                source: typeof source === 'string'
                    ? source
                    : rawNodes.get(source).repr,
            },
        };
    }
    if (repr !== null) {
        return { id, type, size, repr };
    }
    return { id, type, size };
}
function normalizeRawEdge({ type, to, from, name }, nodeNames) {
    if (typeof name === 'string') {
        return { type, to, from, name };
    }
    if (typeof name === 'number') {
        return {
            type,
            to,
            from,
            name: nodeNames.get(name),
        };
    }
    return {
        type,
        to,
        from,
        name: undefined,
    };
}
function flattenEdgesForV8(graph, stringMapper) {
    const out = new Uint32Array(graph.size * 3);
    const nodeIdToFlatIndex = new Map();
    let nodeIdx = 0;
    graph.forEachNode((id) => {
        nodeIdToFlatIndex.set(id, nodeIdx * 7);
        nodeIdx += 1;
    });
    let i = 0;
    graph.forEachNode((id) => {
        let hiddenEdgeIndexInNode = 0;
        graph.forEachOutEdge(id, (_, edge, _2, targetNode) => {
            var _a;
            out[i] = types_1.edgeTypeMap.get(edge.type);
            if (edge.type === 'hidden' || edge.type === 'element') {
                out[i + 1] = hiddenEdgeIndexInNode + 1;
                hiddenEdgeIndexInNode += 1;
            }
            else {
                out[i + 1] = stringMapper.addString((_a = edge.name) !== null && _a !== void 0 ? _a : '');
            }
            out[i + 2] = nodeIdToFlatIndex.get(targetNode);
            i += 3;
        });
    });
    return Array.from(out);
}
function flattenNodesForV8(graph, stringMapper) {
    const out = new Uint32Array(graph.order * 7);
    let i = 0;
    graph.forEachNode((id, node) => {
        var _a, _b;
        const edgeCount = graph.outEdges(id).length;
        out[i] = types_1.nodeTypeMap.get(node.type);
        out[i + 1] = stringMapper.addString((_a = node.name) !== null && _a !== void 0 ? _a : '');
        out[i + 2] = Number.parseInt(id, 10);
        out[i + 3] = (_b = node.memory_size) !== null && _b !== void 0 ? _b : 0;
        out[i + 4] = edgeCount;
        out[i + 5] = out[i + 6] = 0;
        i += 7;
    });
    return Array.from(out);
}
function generateNodeName(node, nodeIdToSource) {
    var _a;
    let name = node.repr || ((_a = node.position) === null || _a === void 0 ? void 0 : _a.name);
    if (nodeIdToSource.has(node.id)) {
        const s = nodeIdToSource.get(node.id);
        const pos = `${s.source}:${s.line}`;
        if (name)
            name += ' - ' + pos;
        else
            name = pos;
    }
    return name !== null && name !== void 0 ? name : '';
}
function mapNodeToSource(nodes, rawSourceMaps) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const sourceMapConsumers = yield mapValues(lodash(rawSourceMaps).pickBy().value(), (map) => tslib_1.__awaiter(this, void 0, void 0, function* () { return new source_map_1.SourceMapConsumer(map); }));
        const out = new Map();
        nodes.forEach((node) => {
            if ('position' in node) {
                const { line, column, source } = node.position;
                const sourceMap = sourceMapConsumers[path.posix.normalize(source)];
                if (!sourceMap)
                    return;
                const mappedPosition = sourceMap.originalPositionFor({
                    column,
                    line: line + 1,
                });
                if (mappedPosition.source === null)
                    return;
                out.set(node.id, {
                    line: mappedPosition.line,
                    column: mappedPosition.column,
                    source: mappedPosition.source,
                });
            }
        });
        return out;
    });
}
function generateGraph(snapshotBuffer, version, rawSourceMaps) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (version !== 'jerryscript-1') {
            throw new Error(`Unknown heap snapshot format "${version}"`);
        }
        const snapshotCBOR = cbor.decodeFirstSync(snapshotBuffer);
        const { meta: jerryMeta, items: packedItems } = validateOrThrow(types_1.HeapSnapshot, snapshotCBOR);
        const rawNodes = new Map();
        const rawEdges = [];
        let i = 0;
        while (i < packedItems.length) {
            const itemType = jerryMeta.types[packedItems[i]];
            const isNode = types_1.NodeTypes.is(itemType);
            i += 1;
            function unpackFields(fieldNames) {
                const fields = {};
                fieldNames.forEach((fieldName) => {
                    fields[fieldName] = packedItems[i];
                    i += 1;
                });
                return fields;
            }
            if (isNode) {
                const rawNode = validateOrThrow(types_1.RawNode, Object.assign({ type: itemType }, unpackFields(jerryMeta.nodeFields)));
                rawNodes.set(rawNode.id, rawNode);
            }
            else {
                rawEdges.push(validateOrThrow(types_1.RawEdge, Object.assign({ type: itemType }, unpackFields(jerryMeta.edgeFields))));
            }
        }
        const nodeMap = new Map();
        for (const [_, rawNode] of rawNodes) {
            nodeMap.set(rawNode.id, normalizeRawNode(rawNode, rawNodes));
        }
        const nodeIdToSource = yield mapNodeToSource(nodeMap, rawSourceMaps);
        const nodeNames = new Map([...nodeMap.values()].map((n) => [
            n.id,
            generateNodeName(n, nodeIdToSource),
        ]));
        const normalizedEdges = rawEdges.map((rawEdge) => normalizeRawEdge(rawEdge, nodeNames));
        const dcg = new graphology_1.MultiDirectedGraph();
        for (const [id, node] of nodeMap) {
            dcg.addNode(id.toString(), {
                name: nodeNames.get(id),
                type: node.type,
                memory_size: node.size,
            });
        }
        for (const e of normalizedEdges) {
            dcg.addEdge(e.from.toString(), e.to.toString(), {
                name: (_a = e.name) !== null && _a !== void 0 ? _a : null,
                type: e.type,
            });
        }
        assert(dcg.order === nodeMap.size);
        assert(dcg.size === normalizedEdges.length);
        return dcg;
    });
}
exports.generateGraph = generateGraph;
function generateV8HeapSnapshot(graph) {
    const stringMapper = new StringMapper();
    const nodeList = flattenNodesForV8(graph, stringMapper);
    const edgesList = flattenEdgesForV8(graph, stringMapper);
    v8SanityChecks(graph, nodeList, edgesList);
    const meta = {
        node_fields: [
            'type',
            'name',
            'id',
            'self_size',
            'edge_count',
            'trace_node_id',
            'detachedness',
        ],
        node_types: [
            types_1.nodeTypeList.map((nt) => types_1.v8NodeTypes.get(nt)),
            'string',
            'number',
            'number',
            'number',
            'number',
            'number',
        ],
        edge_fields: ['type', 'name_or_index', 'to_node'],
        edge_types: [types_1.edgeTypeList, 'string_or_number', 'node'],
    };
    const snapshot = {
        meta,
        node_count: graph.order,
        edge_count: graph.size,
        trace_function_count: 0,
    };
    return {
        snapshot,
        nodes: nodeList,
        edges: edgesList,
        strings: stringMapper.stringsArray,
    };
}
exports.generateV8HeapSnapshot = generateV8HeapSnapshot;
function v8SanityChecks(graph, nodeList, edgeList) {
    let totalEdgeCounts = 0;
    for (let i = 0; i < nodeList.length; i += 7) {
        totalEdgeCounts += nodeList[i + 4];
    }
    assert(totalEdgeCounts === edgeList.length / 3);
    assert(totalEdgeCounts === graph.size);
    assert(graph.order === nodeList.length / 7);
}
//# sourceMappingURL=convert.js.map