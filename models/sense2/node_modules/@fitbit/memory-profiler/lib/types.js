"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.edgeTypeList = exports.edgeTypeMap = exports.nodeTypeList = exports.nodeTypeMap = exports.RawEdge = exports.Edge = exports.Node = exports.RawNode = exports.RawPosition = exports.HeapSnapshot = exports.EdgeFields = exports.NodeFields = exports.EdgeTypes = exports.v8NodeTypes = exports.NodeTypes = void 0;
const t = require("io-ts");
const fdb_protocol_1 = require("@fitbit/fdb-protocol");
exports.NodeTypes = t.union([
    t.literal('Hidden'),
    t.literal('Array'),
    t.literal('String'),
    t.literal('Object'),
    t.literal('Code'),
    t.literal('Sourcemap'),
    t.literal('Closure'),
    t.literal('Regexp'),
    t.literal('Heapnumber'),
    t.literal('Native'),
    t.literal('Synthetic'),
    t.literal('Constring'),
    t.literal('Slicedstring'),
    t.literal('Symbol'),
    t.literal('Bigint'),
]);
exports.v8NodeTypes = new Map([
    ['Hidden', 'hidden'],
    ['Array', 'array'],
    ['String', 'string'],
    ['Object', 'object'],
    ['Code', 'code'],
    ['Sourcemap', 'source map'],
    ['Closure', 'closure'],
    ['Regexp', 'regexp'],
    ['Heapnumber', 'heap number'],
    ['Native', 'native'],
    ['Synthetic', 'synthetic'],
    ['Constring', 'concatenated string'],
    ['Slicedstring', 'sliced string'],
    ['Symbol', 'symbol'],
    ['Bigint', 'bigint'],
]);
exports.EdgeTypes = t.union([
    t.literal('hidden'),
    t.literal('lexenv'),
    t.literal('prototype'),
    t.literal('bind'),
    t.literal('this'),
    t.literal('bindargs'),
    t.literal('element'),
    t.literal('property'),
    t.literal('propertyname'),
    t.literal('propertyget'),
    t.literal('propertyset'),
    t.literal('promiseresult'),
    t.literal('promisefulfill'),
    t.literal('promisereject'),
    t.literal('scope'),
    t.literal('shortcut'),
    t.literal('weak'),
]);
exports.NodeFields = t.union([
    t.literal('id'),
    t.literal('size'),
    t.literal('repr'),
]);
exports.EdgeFields = t.union([
    t.literal('from'),
    t.literal('to'),
    t.literal('name'),
]);
exports.HeapSnapshot = t.interface({
    meta: t.interface({
        types: t.array(t.union([exports.NodeTypes, exports.EdgeTypes])),
        nodeFields: t.array(exports.NodeFields),
        edgeFields: t.array(exports.EdgeFields),
    }),
    items: t.any,
}, 'HeapSnapshot');
exports.RawPosition = t.union([
    t.string,
    t.tuple([
        t.union([t.number, t.string]),
        t.number,
        t.number,
        t.union([t.null, t.string]),
    ]),
    t.null,
]);
exports.RawNode = t.interface({
    type: exports.NodeTypes,
    id: t.number,
    size: t.union([t.number, t.null]),
    repr: exports.RawPosition,
}, 'RawNode');
exports.Node = t.intersection([
    t.interface({
        type: exports.NodeTypes,
        id: t.number,
        size: t.union([t.number, t.null]),
    }),
    t.union([
        t.interface({
            position: fdb_protocol_1.FDBTypes.Position,
        }),
        t.partial({
            repr: t.string,
        }),
    ]),
], 'Node');
exports.Edge = t.intersection([
    t.interface({
        type: exports.EdgeTypes,
        to: t.number,
        from: t.number,
    }),
    t.partial({
        name: t.string,
    }),
], 'Edge');
exports.RawEdge = t.interface({
    type: exports.EdgeTypes,
    to: t.number,
    from: t.number,
    name: t.union([t.number, t.string, t.null]),
}, 'RawEdge');
exports.nodeTypeMap = new Map(exports.NodeTypes.types.map((t, i) => [t.value, i]));
exports.nodeTypeList = [...exports.nodeTypeMap.keys()];
exports.edgeTypeMap = new Map(exports.EdgeTypes.types.map((t, i) => [t.value, i]));
exports.edgeTypeList = [...exports.edgeTypeMap.keys()];
//# sourceMappingURL=types.js.map