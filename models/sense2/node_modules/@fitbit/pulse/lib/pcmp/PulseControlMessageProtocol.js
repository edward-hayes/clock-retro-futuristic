"use strict";
/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PCMPCode = void 0;
var tslib_1 = require("tslib");
var events_1 = (0, tslib_1.__importDefault)(require("events"));
var PCMPPacket_1 = (0, tslib_1.__importDefault)(require("./PCMPPacket"));
var PCMPCode;
(function (PCMPCode) {
    PCMPCode[PCMPCode["EchoRequest"] = 1] = "EchoRequest";
    PCMPCode[PCMPCode["EchoReply"] = 2] = "EchoReply";
    PCMPCode[PCMPCode["DiscardRequest"] = 3] = "DiscardRequest";
    PCMPCode[PCMPCode["PortClosed"] = 129] = "PortClosed";
    PCMPCode[PCMPCode["UnknownCode"] = 130] = "UnknownCode";
})(PCMPCode = exports.PCMPCode || (exports.PCMPCode = {}));
/*
  This protocol is unique in that it is logically part of the
  transport but is layered on top of the transport over the wire.
  It acts like a socket and a protocol all in one.
*/
var PulseControlMessageProtocol = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(PulseControlMessageProtocol, _super);
    function PulseControlMessageProtocol(transport) {
        var _this = _super.call(this) || this;
        _this.transport = transport;
        _this.port = 0x0001;
        _this.mtu = 0;
        _this.closed = false;
        _this.pingAttemptsRemaining = 0;
        _this.pingTimeout = 0;
        return _this;
    }
    PulseControlMessageProtocol.prototype.close = function () {
        if (this.closed)
            return;
        this.closed = true;
        if (this.pingPromiseReject) {
            this.pingPromiseReject(new Error('Ping failed: socket closed'));
        }
        this.resetPingTimer();
        this.transport.unregisterSocket(this.port);
    };
    PulseControlMessageProtocol.prototype.sendUnknownCode = function (code) {
        var buf = Buffer.alloc(1);
        buf.writeUInt8(code);
        this.transport.send(this.port, PCMPPacket_1.default.build(PCMPCode.UnknownCode, buf));
    };
    PulseControlMessageProtocol.prototype.sendEchoRequest = function (data) {
        if (data === void 0) { data = Buffer.alloc(0); }
        this.transport.send(this.port, PCMPPacket_1.default.build(PCMPCode.EchoRequest, data));
    };
    PulseControlMessageProtocol.prototype.sendEchoReply = function (data) {
        this.transport.send(this.port, PCMPPacket_1.default.build(PCMPCode.EchoReply, data));
    };
    PulseControlMessageProtocol.prototype.onReceive = function (rawPacket) {
        var packet;
        try {
            packet = PCMPPacket_1.default.parse(rawPacket);
        }
        catch (_a) {
            console.error('Received malformed PCMP packet');
            return;
        }
        if (!Object.values(PCMPCode).includes(packet.code)) {
            console.error("Received PCMP packet with unknown code: ".concat(packet.code.toString(16)));
            this.sendUnknownCode(packet.code);
            return;
        }
        var code = packet.code;
        switch (code) {
            case PCMPCode.DiscardRequest:
                break;
            case PCMPCode.EchoRequest:
                this.sendEchoReply(packet.information);
                break;
            case PCMPCode.EchoReply:
                if (this.pingPromiseResolve)
                    this.pingPromiseResolve();
                this.resetPingTimer();
                break;
            case PCMPCode.PortClosed:
                if (packet.information.byteLength === 2) {
                    var closedPort = packet.information.readUInt16BE();
                    this.emit('portClosed', closedPort);
                }
                else {
                    console.error("Remote peer sent malformed Port-Closed packet: ".concat(packet.information.toString('hex')));
                }
                break;
            case PCMPCode.UnknownCode:
                if (packet.information.byteLength === 1) {
                    console.error("Remote peer sent Unknown-Code(".concat(packet.information.readUInt8(), ") packet"));
                }
                else {
                    console.error("Remote peer sent malformed Unknown-Code packet: ".concat(packet.information.toString('hex')));
                }
                break;
            default:
                /* istanbul ignore next */
                throw new Error('PCMP machine did not handle known code');
        }
    };
    /*
      Test the link quality by sending Echo-Request packets and
      listening for Echo-Reply packets from the remote peer.
  
      The ping is performed asynchronously, with the result returned as Promise.
      It will resolve if the ping is successful, or reject if all attempts/timeouts
      are exhausted and it is not.
    */
    PulseControlMessageProtocol.prototype.ping = function (attempts, timeout) {
        var _this = this;
        if (attempts === void 0) { attempts = 3; }
        if (timeout === void 0) { timeout = 1000; }
        if (attempts < 1) {
            return Promise.reject(new Error('attempts must be positive'));
        }
        if (timeout <= 0) {
            return Promise.reject(new Error('timeout must be positive'));
        }
        if (this.pingTimer !== undefined) {
            return Promise.reject(new Error('Another ping is currently in progress'));
        }
        this.pingAttemptsRemaining = attempts - 1;
        this.pingTimeout = timeout;
        this.sendEchoRequest();
        this.pingTimer = setTimeout(this.pingTimerExpired.bind(this), timeout);
        return new Promise(function (resolve, reject) {
            _this.pingPromiseResolve = resolve;
            _this.pingPromiseReject = reject;
        });
    };
    PulseControlMessageProtocol.prototype.resetPingTimer = function () {
        if (this.pingTimer !== undefined) {
            clearTimeout(this.pingTimer);
            this.pingTimer = undefined;
        }
        this.pingAttemptsRemaining = 0;
        this.pingPromiseResolve = undefined;
        this.pingPromiseReject = undefined;
    };
    PulseControlMessageProtocol.prototype.pingTimerExpired = function () {
        if (this.pingAttemptsRemaining > 0) {
            this.pingAttemptsRemaining -= 1;
            this.sendEchoRequest();
            this.pingTimer = setTimeout(this.pingTimerExpired.bind(this), this.pingTimeout);
        }
        else {
            if (this.pingPromiseReject) {
                this.pingPromiseReject(new Error('Ping timed out'));
            }
            this.resetPingTimer();
        }
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    PulseControlMessageProtocol.prototype.send = function (data) {
        throw new Error('PCMP cannot be used as a socket');
    };
    return PulseControlMessageProtocol;
}(events_1.default));
exports.default = PulseControlMessageProtocol;
//# sourceMappingURL=PulseControlMessageProtocol.js.map