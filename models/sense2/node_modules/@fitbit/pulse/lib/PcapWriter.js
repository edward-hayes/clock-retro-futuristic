"use strict";
/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PcapPacketDirection = void 0;
var tslib_1 = require("tslib");
var fs = (0, tslib_1.__importStar)(require("fs"));
var PcapPacketDirection;
(function (PcapPacketDirection) {
    PcapPacketDirection[PcapPacketDirection["IN"] = 0] = "IN";
    PcapPacketDirection[PcapPacketDirection["OUT"] = 1] = "OUT";
})(PcapPacketDirection = exports.PcapPacketDirection || (exports.PcapPacketDirection = {}));
var PcapWriter = /** @class */ (function () {
    function PcapWriter(path, linkType) {
        this.fd = fs.openSync(path, 'w');
        this.writeHeader(linkType);
    }
    PcapWriter.prototype.close = function () {
        fs.closeSync(this.fd);
    };
    PcapWriter.prototype.writeHeader = function (linkType) {
        var buf = Buffer.alloc(24);
        var offset = 0;
        // magic_number
        buf.writeUInt32BE(0xa1b2c3d4, offset);
        offset += 4;
        // version_major
        buf.writeUInt16BE(2, offset);
        offset += 2;
        // version_minor
        buf.writeUInt16BE(4, offset);
        offset += 2;
        // thiszone (GMT to local time correction)
        buf.writeInt32BE(0, offset);
        offset += 4;
        // sigfigs (accuracy of timestamps)
        buf.writeUInt32BE(0, offset);
        offset += 4;
        // snaplen (max length of captured packets, in octets)
        buf.writeUInt32BE(65535, offset);
        offset += 4;
        // network
        buf.writeUInt32BE(linkType, offset);
        fs.writeSync(this.fd, buf);
    };
    PcapWriter.prototype.writePacket = function (direction, data) {
        if (data.byteLength > 0xffff) {
            throw new Error('Data too large to write to pcap file');
        }
        var buf = Buffer.alloc(17);
        var timestamp = Date.now();
        var seconds = Math.floor(timestamp / 1000);
        var microseconds = (timestamp - seconds * 1000) * 1000;
        var offset = buf.writeUInt32BE(seconds);
        offset = buf.writeUInt32BE(microseconds, offset);
        offset = buf.writeUInt32BE(data.byteLength, offset);
        offset = buf.writeUInt32BE(data.byteLength, offset);
        buf.writeUInt8(direction, offset);
        fs.writeSync(this.fd, buf);
        fs.writeSync(this.fd, data);
    };
    PcapWriter.linkTypePPPWithDir = 204;
    return PcapWriter;
}());
exports.default = PcapWriter;
//# sourceMappingURL=PcapWriter.js.map