"use strict";
/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ReliableSupervisoryPacket_1 = (0, tslib_1.__importStar)(require("./ReliableSupervisoryPacket"));
var BaseTransport_1 = (0, tslib_1.__importDefault)(require("./BaseTransport"));
var ReliableInfoPacket_1 = (0, tslib_1.__importDefault)(require("./ReliableInfoPacket"));
// % is not the same in C/JS as it is in Python
// -1 % 128 = 127 in Python, but -1 in C/JS
function modulus(a, n) {
    return ((a % n) + n) % n;
}
var ReliableTransport = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(ReliableTransport, _super);
    function ReliableTransport(intf, linkMtu) {
        var _this = _super.call(this, intf) || this;
        _this.retransmitCount = 0;
        _this.waitingForAck = false;
        _this.sendQueue = [];
        // The sequence number of the next in-sequence I-packet to be TX'ed
        _this.sendVariable = 0;
        // The expected sequence number of the next received I-packet
        _this.receiveVariable = 0; // V(R) in LAPB
        _this._mtu = linkMtu - 6;
        _this.commandSocket = intf.connect(ReliableTransport.commandProtocolNumber);
        _this.commandSocket.on('data', _this.commandPacketReceived.bind(_this));
        _this.responseSocket = intf.connect(ReliableTransport.responseProtocolNumber);
        _this.responseSocket.on('data', _this.responsePacketReceived.bind(_this));
        return _this;
    }
    ReliableTransport.prototype.thisLayerUp = function () {
        _super.prototype.thisLayerUp.call(this);
        this.sendVariable = 0;
        this.receiveVariable = 0;
        this.retransmitCount = 0;
        this.waitingForAck = false;
        // Send an RR command packet to elicit an RR response from the
        // remote peer. Receiving a response from the peer confirms that
        // the transport is ready to carry traffic, at which point we
        // will allow applications to start opening sockets.
        this.sendSupervisoryCommand(ReliableSupervisoryPacket_1.SupervisoryPacketKind.RR, true);
        this.startRetransmitTimer();
    };
    ReliableTransport.prototype.thisLayerDown = function () {
        this.opened.clear();
        if (this.retransmitTimer) {
            clearInterval(this.retransmitTimer);
            this.retransmitTimer = undefined;
        }
        this.closeAllSockets();
    };
    ReliableTransport.prototype.down = function () {
        _super.prototype.down.call(this);
        this.commandSocket.close();
        this.responseSocket.close();
    };
    ReliableTransport.prototype.sendInfoPacket = function (port, information) {
        var packet = ReliableInfoPacket_1.default.build(this.sendVariable, this.receiveVariable, true, port, information);
        this.commandSocket.send(packet);
    };
    ReliableTransport.prototype.send = function (port, information) {
        _super.prototype.send.call(this, port, information);
        this.sendQueue.push([port, information]);
        this.pumpSendQueue();
    };
    ReliableTransport.prototype.processAck = function (ackNumber) {
        if (!this.waitingForAck) {
            // Could be in the timer recovery condition (waiting for
            // a response to an RR Poll command). This is a bit
            // hacky and should probably be changed to use an
            // explicit state machine when this transport is
            // extended to support Go-Back-N ARQ.
            if (this.retransmitTimer !== undefined) {
                clearTimeout(this.retransmitTimer);
                this.retransmitTimer = undefined;
                this.retransmitCount = 0;
            }
        }
        if (modulus(ackNumber - 1, ReliableTransport.modulus) === this.sendVariable) {
            if (this.retransmitTimer) {
                clearTimeout(this.retransmitTimer);
                this.retransmitTimer = undefined;
            }
            this.retransmitCount = 0;
            this.waitingForAck = false;
            this.sendVariable = (this.sendVariable + 1) % ReliableTransport.modulus;
        }
    };
    ReliableTransport.prototype.pumpSendQueue = function () {
        if (this.waitingForAck)
            return;
        if (this.sendQueue.length === 0)
            return;
        var packet = this.sendQueue.splice(0, 1)[0];
        this.lastSentPacket = packet;
        this.waitingForAck = true;
        this.sendInfoPacket.apply(this, (0, tslib_1.__spreadArray)([], (0, tslib_1.__read)(packet), false));
        this.startRetransmitTimer();
    };
    ReliableTransport.prototype.startRetransmitTimer = function () {
        if (this.retransmitTimer) {
            clearTimeout(this.retransmitTimer);
        }
        this.retransmitTimer = setTimeout(this.retransmitTimeoutExpired.bind(this), ReliableTransport.retransmitTimeout);
    };
    ReliableTransport.prototype.retransmitTimeoutExpired = function () {
        var _a;
        this.retransmitCount += 1;
        if (this.retransmitCount >= ReliableTransport.maxRetransmits) {
            console.warn('Reached maximum number of retransmit attempts');
            (_a = this.ncp) === null || _a === void 0 ? void 0 : _a.restart();
            return;
        }
        if (this.lastSentPacket) {
            this.sendInfoPacket.apply(this, (0, tslib_1.__spreadArray)([], (0, tslib_1.__read)(this.lastSentPacket), false));
        }
        else {
            // No info packet to retransmit; must be an RR command
            // that needs to be retransmitted.
            this.sendSupervisoryCommand(ReliableSupervisoryPacket_1.SupervisoryPacketKind.RR, true);
        }
        this.startRetransmitTimer();
    };
    ReliableTransport.prototype.sendSupervisoryCommand = function (kind, poll) {
        if (poll === void 0) { poll = false; }
        var command = ReliableSupervisoryPacket_1.default.build(kind, this.receiveVariable, poll);
        this.commandSocket.send(command);
    };
    ReliableTransport.prototype.sendSupervisoryResponse = function (kind, final) {
        if (final === void 0) { final = false; }
        var command = ReliableSupervisoryPacket_1.default.build(kind, this.receiveVariable, final);
        this.responseSocket.send(command);
    };
    ReliableTransport.prototype.commandPacketReceived = function (packet) {
        var _a;
        if (!((_a = this.ncp) === null || _a === void 0 ? void 0 : _a.isOpened())) {
            console.warn('Received command packet before transport is open. Discarding.');
            return;
        }
        // Information packets have the LSBit of the first byte cleared.
        var isInfo = (packet[0] & 1) === 0;
        var fields;
        try {
            if (isInfo)
                fields = ReliableInfoPacket_1.default.parse(packet);
            else
                fields = ReliableSupervisoryPacket_1.default.parse(packet);
        }
        catch (_b) {
            console.error('Received malformed command packet');
            this.ncp.restart();
            return;
        }
        this.opened.set();
        if (fields instanceof ReliableInfoPacket_1.default) {
            if (fields.sequenceNumber === this.receiveVariable) {
                this.receiveVariable =
                    (this.receiveVariable + 1) % ReliableTransport.modulus;
                var socket = this.sockets[fields.port];
                if (socket === undefined) {
                    console.warn("Received packet on closed port 0x".concat(fields.port.toString(16)));
                }
                else {
                    socket.onReceive(fields.information);
                }
            }
            this.sendSupervisoryResponse(ReliableSupervisoryPacket_1.SupervisoryPacketKind.RR, fields.poll);
        }
        else {
            if (![ReliableSupervisoryPacket_1.SupervisoryPacketKind.RR, ReliableSupervisoryPacket_1.SupervisoryPacketKind.REJ].includes(fields.kind)) {
                console.error("Received a command packet which is not yet supported by this implementation: ".concat(fields.kind));
                // Pretend it's an RR packet, fallthrough
            }
            this.processAck(fields.ackNumber);
            if (fields.poll) {
                this.sendSupervisoryResponse(ReliableSupervisoryPacket_1.SupervisoryPacketKind.RR, true);
            }
            this.pumpSendQueue();
        }
    };
    ReliableTransport.prototype.responsePacketReceived = function (packet) {
        var _a;
        if (!((_a = this.ncp) === null || _a === void 0 ? void 0 : _a.isOpened())) {
            console.error('Received response packet before transport is open. Discarding.');
            return;
        }
        // Information packets cannot be responses; we only need to
        // handle receiving Supervisory packets.
        var fields;
        try {
            fields = ReliableSupervisoryPacket_1.default.parse(packet);
        }
        catch (_b) {
            console.error('Received malformed response packet');
            this.ncp.restart();
            return;
        }
        this.opened.set();
        this.processAck(fields.ackNumber);
        this.pumpSendQueue();
        if (![ReliableSupervisoryPacket_1.SupervisoryPacketKind.RR, ReliableSupervisoryPacket_1.SupervisoryPacketKind.REJ].includes(fields.kind)) {
            console.error("Received a response packet which is not yet supported by this implementation: ".concat(fields.kind));
        }
    };
    ReliableTransport.displayName = 'TRAIN';
    ReliableTransport.ncpProtocolNumber = 0xba33;
    ReliableTransport.commandProtocolNumber = 0x3a33;
    ReliableTransport.responseProtocolNumber = 0x3a35;
    ReliableTransport.modulus = 128;
    ReliableTransport.maxRetransmits = 10; // N2 system parameter in LAPB
    ReliableTransport.retransmitTimeout = 2000; // T1 system parameter
    return ReliableTransport;
}(BaseTransport_1.default));
exports.default = ReliableTransport;
//# sourceMappingURL=ReliableTransport.js.map