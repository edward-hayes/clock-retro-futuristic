"use strict";
/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Socket_1 = (0, tslib_1.__importDefault)(require("../Socket"));
var PulseControlMessageProtocol_1 = (0, tslib_1.__importDefault)(require("../pcmp/PulseControlMessageProtocol"));
var TransportControlProtocol_1 = (0, tslib_1.__importDefault)(require("./TransportControlProtocol"));
var event_1 = (0, tslib_1.__importDefault)(require("../util/event"));
var BaseTransport = /** @class */ (function () {
    function BaseTransport(intf) {
        this.closed = false;
        this._mtu = 0;
        this.opened = new event_1.default();
        this.sockets = {};
        var ctor = this.constructor;
        if (ctor.ncpProtocolNumber !== undefined) {
            this.ncp = new TransportControlProtocol_1.default(intf, this, ctor.ncpProtocolNumber, ctor.displayName);
            this.ncp.up();
            this.ncp.open();
        }
    }
    Object.defineProperty(BaseTransport.prototype, "mtu", {
        get: function () {
            return this._mtu;
        },
        enumerable: false,
        configurable: true
    });
    BaseTransport.prototype.thisLayerUp = function () {
        // We can't let PCMP bind itself using the public openSocket
        // method as the method will block until this.opened is set, but
        // it won't be set until we use PCMP Echo to test that the
        // transport is ready to carry traffic. So we must manually bind
        // the port without waiting.
        this.pcmp = new PulseControlMessageProtocol_1.default(this);
        this.sockets[this.pcmp.port] = this.pcmp;
        this.pcmp.on('portClosed', this.onPortClosed.bind(this));
    };
    BaseTransport.prototype.thisLayerDown = function () {
        this.opened.clear();
        this.closeAllSockets();
    };
    BaseTransport.prototype.openSocket = function (port, timeout) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var socket;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.closed)
                            throw new Error('Cannot open socket on closed transport');
                        return [4 /*yield*/, this.opened.wait(timeout)];
                    case 1:
                        if (!(_a.sent())) {
                            throw new Error('Timed out waiting for transport to open socket');
                        }
                        if (this.sockets[port] !== undefined) {
                            throw new Error("Another socket is already opened on port 0x".concat(port.toString(16)));
                        }
                        socket = new Socket_1.default(this, port);
                        this.sockets[port] = socket;
                        return [2 /*return*/, socket];
                }
            });
        });
    };
    BaseTransport.prototype.unregisterSocket = function (port) {
        delete this.sockets[port];
    };
    BaseTransport.prototype.send = function (port, information) {
        // Implements only checks shared across transports, data will go nowhere
        // unless child class actually puts it somewhere
        var _a;
        if (this.closed)
            throw new Error('I/O operation on closed transport');
        if (!((_a = this.ncp) === null || _a === void 0 ? void 0 : _a.isOpened())) {
            throw new Error('I/O operation before transport is opened');
        }
        if (information.byteLength > this.mtu) {
            throw new Error("Packet length (".concat(information.byteLength, ") exceeds transport MTU (").concat(this.mtu, ")"));
        }
    };
    /*
      Called by the Link when the link layer goes down.
  
      This closes the Transport object. Once closed, the Transport
      cannot be reopened.
    */
    BaseTransport.prototype.down = function () {
        var _a;
        (_a = this.ncp) === null || _a === void 0 ? void 0 : _a.down();
        this.closed = true;
        this.closeAllSockets();
    };
    BaseTransport.prototype.closeAllSockets = function () {
        var e_1, _a;
        try {
            for (var _b = (0, tslib_1.__values)(Object.values(this.sockets)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var socket = _c.value;
                socket.close();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.sockets = {};
    };
    BaseTransport.prototype.onPortClosed = function (port) {
        try {
            this.sockets[port].close();
        }
        catch (_a) {
            console.error("No socket is open on port 0x".concat(port.toString(16), "!"));
        }
    };
    BaseTransport.displayName = 'BaseTransport';
    BaseTransport.protocolNumber = 0x0;
    return BaseTransport;
}());
exports.default = BaseTransport;
//# sourceMappingURL=BaseTransport.js.map