"use strict";
/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var stream = (0, tslib_1.__importStar)(require("stream"));
var InterfaceSocket_1 = (0, tslib_1.__importDefault)(require("./InterfaceSocket"));
var Link_1 = (0, tslib_1.__importDefault)(require("./Link"));
var LinkControlProtocol_1 = (0, tslib_1.__importDefault)(require("./ppp/LinkControlProtocol"));
var PPPFrame_1 = (0, tslib_1.__importDefault)(require("./ppp/PPPFrame"));
var event_1 = (0, tslib_1.__importDefault)(require("./util/event"));
var decoder_1 = require("./framing/decoder");
var encoder_1 = require("./framing/encoder");
var splitter_1 = require("./framing/splitter");
var PcapWriter_1 = (0, tslib_1.__importStar)(require("./PcapWriter"));
var Interface = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(Interface, _super);
    function Interface(options) {
        var _this = _super.call(this, { objectMode: true, allowHalfOpen: false }) || this;
        _this.isClosed = false;
        _this.sockets = {};
        _this.lcp = new LinkControlProtocol_1.default(_this);
        _this.linkAvailable = new event_1.default();
        _this.requestedTransports = options === null || options === void 0 ? void 0 : options.requestedTransports;
        if (options === null || options === void 0 ? void 0 : options.pcapPath) {
            _this.pcapWriter = new PcapWriter_1.default(options.pcapPath, PcapWriter_1.default.linkTypePPPWithDir);
        }
        _this.lcp.addListener('linkUp', _this.onLinkUp.bind(_this));
        _this.lcp.addListener('linkDown', _this.onLinkDown.bind(_this));
        _this.once('pipe', function () {
            _this.lcp.up();
            _this.lcp.open();
        });
        return _this;
    }
    Interface.create = function (phy, options) {
        var intf = new Interface(options);
        var splitter = new splitter_1.FrameSplitter();
        var decoder = new decoder_1.FrameDecoder();
        var encoder = new encoder_1.FrameEncoder();
        stream.pipeline([phy, splitter, decoder, intf, encoder, phy], function () {
            intf.down();
        });
        return intf;
    };
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    Interface.prototype._read = function () { };
    Interface.prototype._write = function (chunk, _, callback) {
        if (this.pcapWriter) {
            this.pcapWriter.writePacket(PcapWriter_1.PcapPacketDirection.IN, chunk);
        }
        var frame;
        try {
            frame = PPPFrame_1.default.parse(chunk);
        }
        catch (_a) {
            console.warn("Received malformed PPP frame: ".concat(chunk.toString('hex')));
            callback();
            return;
        }
        var socket = this.sockets[frame.protocol];
        if (socket !== undefined) {
            socket.handlePacket(frame.information);
        }
        else {
            // Protocol-reject
        }
        callback();
    };
    /*
      Open a link-layer socket for sending and receiving packets
      of a specific protocol number.
    */
    Interface.prototype.connect = function (protocol) {
        if (this.sockets[protocol] !== undefined) {
            throw new Error("A socket is already bound to protocol 0x".concat(protocol.toString(16)));
        }
        return (this.sockets[protocol] = new InterfaceSocket_1.default(this, protocol));
    };
    /*
      Used by InterfaceSocket objets to unregister themselves when closing.
    */
    Interface.prototype.unregisterSocket = function (protocol) {
        delete this.sockets[protocol];
    };
    Interface.prototype.sendPacket = function (protocol, packet) {
        if (this.isClosed)
            throw new Error('I/O operation on closed interface');
        var datagram = PPPFrame_1.default.build(protocol, packet);
        if (this.pcapWriter) {
            this.pcapWriter.writePacket(PcapWriter_1.PcapPacketDirection.OUT, datagram);
        }
        this.push(datagram);
    };
    Interface.prototype.closeAllSockets = function () {
        var e_1, _a;
        try {
            for (var _b = (0, tslib_1.__values)(Object.values(this.sockets)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var socket = _c.value;
                socket.close();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    Interface.prototype.close = function () {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isClosed)
                            return [2 /*return*/];
                        return [4 /*yield*/, this.lcp.shutdown()];
                    case 1:
                        _a.sent();
                        this.closeAllSockets();
                        this.down();
                        return [2 /*return*/];
                }
            });
        });
    };
    /*
      The lower layer (iostream) is down. Bring down the interface.
    */
    Interface.prototype.down = function () {
        this.isClosed = true;
        this.closeAllSockets();
        this.lcp.down();
        this.destroy();
    };
    Interface.prototype.handlePingSuccess = function () {
        var mtu = 500;
        this.link = new Link_1.default(this, mtu, this.requestedTransports);
        this.linkAvailable.set();
    };
    Interface.prototype.handlePingFailure = function () {
        // This will trigger a new ping via onLinkUp
        this.lcp.restart();
    };
    Interface.prototype.onLinkUp = function () {
        void this.lcp
            .ping()
            .then(this.handlePingSuccess.bind(this), this.handlePingFailure.bind(this));
    };
    Interface.prototype.onLinkDown = function () {
        if (this.link) {
            this.link.down();
            this.link = undefined;
        }
    };
    Interface.prototype.getLink = function (timeout) {
        if (timeout === void 0) { timeout = 60000; }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var isLinkAvailable;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isClosed) {
                            return [2 /*return*/, Promise.reject(new Error('No link available on closed interface'))];
                        }
                        return [4 /*yield*/, this.linkAvailable.wait(timeout)];
                    case 1:
                        isLinkAvailable = _a.sent();
                        if (isLinkAvailable) {
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            return [2 /*return*/, this.link];
                        }
                        else {
                            throw new Error('Timed out getting link');
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    return Interface;
}(stream.Duplex));
exports.default = Interface;
//# sourceMappingURL=Interface.js.map