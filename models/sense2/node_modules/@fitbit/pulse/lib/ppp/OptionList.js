"use strict";
/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Option = void 0;
var tslib_1 = require("tslib");
var Option = /** @class */ (function () {
    function Option(type, data) {
        this.type = type;
        this.data = data;
    }
    Object.defineProperty(Option.prototype, "wireSize", {
        get: function () {
            return this.data.byteLength + Option.headerSize;
        },
        enumerable: false,
        configurable: true
    });
    Option.parse = function (buf) {
        if (buf.byteLength < Option.headerSize) {
            throw new Error('Option truncated or corrupt');
        }
        var offset = 0;
        var type = buf.readUInt8(offset++);
        var length = buf.readUInt8(offset++);
        if (length < Option.headerSize) {
            throw new Error('Option length less than minimum size');
        }
        if (buf.byteLength < length) {
            throw new Error('Option specified more bytes than available');
        }
        var data = buf.slice(offset, offset + length - Option.headerSize);
        return new this(type, data);
    };
    Option.build = function (type, data) {
        if (data === void 0) { data = Buffer.alloc(0); }
        var buf = Buffer.alloc(Option.headerSize);
        var offset = 0;
        buf.writeUInt8(type, offset++);
        buf.writeUInt8(data.byteLength + Option.headerSize, offset++);
        return Buffer.concat([buf, data]);
    };
    Option.headerSize = 2;
    return Option;
}());
exports.Option = Option;
var OptionList = /** @class */ (function () {
    function OptionList(options) {
        this.options = options;
    }
    OptionList.parse = function (buf) {
        var offset = 0;
        var options = [];
        while (offset < buf.byteLength) {
            var option = Option.parse(buf.slice(offset));
            options.push(option);
            offset += option.wireSize;
        }
        return new this(options);
    };
    OptionList.build = function (options) {
        return Buffer.concat(options.map(function (_a) {
            var _b = (0, tslib_1.__read)(_a, 2), type = _b[0], data = _b[1];
            return Option.build(type, data);
        }));
    };
    return OptionList;
}());
exports.default = OptionList;
//# sourceMappingURL=OptionList.js.map