/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference types="node" />
import EventEmitter from 'events';
import InterfaceSocket from '../InterfaceSocket';
import LCPEncapsulation from './LCPEncapsulation';
import OptionList from './OptionList';
export declare enum ControlCode {
    ConfigureRequest = 1,
    ConfigureAck = 2,
    ConfigureNak = 3,
    ConfigureReject = 4,
    TerminateRequest = 5,
    TerminateAck = 6,
    CodeReject = 7
}
export declare enum ControlProtocolState {
    Initial = "initial",
    Starting = "starting",
    Closed = "closed",
    Stopped = "stopped",
    Closing = "closing",
    Stopping = "stopping",
    ReqSent = "req-sent",
    AckRcvd = "ack-rcvd",
    AckSent = "ack-sent",
    Opened = "opened"
}
export default class ControlProtocol extends EventEmitter {
    protected displayName: string;
    private static readonly maxTerminate;
    private static readonly maxConfigure;
    private static readonly maxFailure;
    private static readonly restartTimeout;
    private static readonly mtu;
    protected state: ControlProtocolState;
    private socket?;
    private restartTimer?;
    private restartCount;
    private configureRequestIdentifier;
    private codeRejectIdentifier;
    private lastSentConfigureOptions;
    private lastSentConfigureRequest;
    private configureFailCount;
    private isFinished;
    constructor(displayName: string);
    private maybeStopRestartTimer;
    private handleEventCallback;
    private addStateTrigger;
    private _up;
    private _down;
    open: (...args: unknown[]) => void;
    close: (...args: unknown[]) => void;
    private timeoutRetry;
    private timeoutGiveup;
    private receiveConfigureRequestAcceptable;
    private receiveConfigureRequestUnacceptable;
    private receiveConfigureAck;
    private receiveConfigureNakOrRej;
    private receiveTerminateRequest;
    private receiveTerminateAck;
    private receiveCodeRejectPermitted;
    private receiveCodeRejectCatastrophic;
    restart(): void;
    up(socket: InterfaceSocket): void;
    down(): void;
    shutdown(): Promise<void>;
    isOpened(): boolean;
    private getCodeRejectIdentifier;
    private getConfigureRequestIdentifier;
    private startRestartTimer;
    private stopRestartTimer;
    private decrementAndStartRestartTimer;
    private restartTimerExpired;
    protected thisLayerUp(): void;
    protected thisLayerDown(): void;
    protected thisLayerStarted(): void;
    protected thisLayerFinished(): void;
    sendPacket(packet: Buffer): void;
    private _thisLayerFinished;
    private initConfigureRestartCount;
    private initTerminateRestartCount;
    private zeroRestartCount;
    private sendConfigureRequest;
    private retransmitConfigureRequest;
    private sendConfigureAck;
    private sendConfigureNakOrRej;
    private sendTerminateRequest;
    private sendTerminateAck;
    private sendCodeReject;
    private packetReceived;
    private handleConfigureRequest;
    protected handleIncomingConfigureRequest(options: OptionList): true | OptionList;
    protected getConfigureRequestOptions(): [number, Buffer][];
    protected handleConfigureReject(unacceptableOptions: OptionList): void;
    protected handleConfigureNak(unacceptableOptions: OptionList): void;
    protected handleConfigureAccepted(options: OptionList): void;
    protected handleUnknownCode(code: number, identifier: number, data: Buffer): boolean;
    protected handleCodeReject(rejectedPacket: LCPEncapsulation): boolean;
}
