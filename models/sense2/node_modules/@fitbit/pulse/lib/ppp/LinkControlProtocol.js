"use strict";
/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LCPCode = void 0;
var tslib_1 = require("tslib");
var ControlProtocol_1 = (0, tslib_1.__importStar)(require("./ControlProtocol"));
var LCPEncapsulation_1 = (0, tslib_1.__importDefault)(require("./LCPEncapsulation"));
var MagicPlusData_1 = (0, tslib_1.__importDefault)(require("./MagicPlusData"));
var identifierGenerator_1 = (0, tslib_1.__importDefault)(require("../util/identifierGenerator"));
// LCP-specific Code values
var LCPCode;
(function (LCPCode) {
    LCPCode[LCPCode["ProtocolReject"] = 8] = "ProtocolReject";
    LCPCode[LCPCode["EchoRequest"] = 9] = "EchoRequest";
    LCPCode[LCPCode["EchoReply"] = 10] = "EchoReply";
    LCPCode[LCPCode["DiscardRequest"] = 11] = "DiscardRequest";
    LCPCode[LCPCode["Identification"] = 12] = "Identification";
})(LCPCode = exports.LCPCode || (exports.LCPCode = {}));
var LinkControlProtocol = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(LinkControlProtocol, _super);
    function LinkControlProtocol(intf) {
        var _this = _super.call(this, 'LCP') || this;
        _this.intf = intf;
        _this.echoRequestIdentifier = (0, identifierGenerator_1.default)();
        _this.lastSentEchoRequestIdentifier = 255;
        _this.lastSentEchoRequestData = Buffer.alloc(0);
        _this.pingAttemptsRemaining = 0;
        _this.pingTimeout = 0;
        return _this;
    }
    LinkControlProtocol.prototype.resetPingTimer = function () {
        if (this.pingTimer !== undefined) {
            clearTimeout(this.pingTimer);
            this.pingTimer = undefined;
            this.pingPromiseResolve = undefined;
            this.pingPromiseReject = undefined;
        }
    };
    LinkControlProtocol.prototype.up = function () {
        _super.prototype.up.call(this, this.intf.connect(0xc021));
    };
    LinkControlProtocol.prototype.handleUnknownCode = function (code, identifier, data) {
        if (!Object.values(LCPCode).includes(code)) {
            return false;
        }
        switch (code) {
            case LCPCode.ProtocolReject:
                break; // TODO: tell NCP that it's been rejected
            case LCPCode.EchoRequest:
                this.handleEchoRequest(identifier, data);
                break;
            case LCPCode.EchoReply:
                this.handleEchoReply(identifier, data);
                break;
            case LCPCode.DiscardRequest:
                break;
            case LCPCode.Identification:
                break; // TODO
            default:
                /* istanbul ignore next */
                throw new Error('Supported LCP code not handled');
        }
        return true;
    };
    LinkControlProtocol.prototype.ping = function (attempts, timeout) {
        var _this = this;
        if (attempts === void 0) { attempts = 3; }
        if (timeout === void 0) { timeout = 1000; }
        if (this.state !== ControlProtocol_1.ControlProtocolState.Opened) {
            return Promise.reject(new Error('Cannot ping when LCP is not opened'));
        }
        if (attempts < 1) {
            return Promise.reject(new Error('attempts must be positive'));
        }
        if (timeout <= 0) {
            return Promise.reject(new Error('timeout must be positive'));
        }
        if (this.pingTimer !== undefined) {
            return Promise.reject(new Error('Another ping is currently in progress'));
        }
        this.pingAttemptsRemaining = attempts - 1;
        this.pingTimeout = timeout;
        this.sendEchoRequest(Buffer.alloc(0));
        this.pingTimer = setTimeout(this.pingTimerExpired.bind(this), timeout);
        return new Promise(function (resolve, reject) {
            _this.pingPromiseResolve = resolve;
            _this.pingPromiseReject = reject;
        });
    };
    LinkControlProtocol.prototype.sendEchoRequest = function (data) {
        this.lastSentEchoRequestIdentifier = this.echoRequestIdentifier();
        this.lastSentEchoRequestData = data;
        this.sendPacket(LCPEncapsulation_1.default.build(LCPCode.EchoRequest, this.lastSentEchoRequestIdentifier, MagicPlusData_1.default.build(0, data)));
    };
    LinkControlProtocol.prototype.handleEchoRequest = function (identifier, data) {
        if (this.state !== ControlProtocol_1.ControlProtocolState.Opened)
            return;
        var request;
        try {
            request = MagicPlusData_1.default.parse(data);
        }
        catch (_a) {
            console.error('Error parsing Echo-Request packet');
            return;
        }
        if (request.magicNumber !== 0) {
            // The Magic-Number option is not implemented, so an
            // Echo-Request packet MUST be transmitted with the
            // Magic-Number field set to zero. An Echo-Request with
            // any other value must therefore be malformed.
            console.warn("Received malformed Echo-Request packet: packet contains nonzero Magic-Number value 0x".concat(request.magicNumber.toString(8)));
            return;
        }
        this.sendPacket(LCPEncapsulation_1.default.build(LCPCode.EchoReply, identifier, MagicPlusData_1.default.build(0, request.data)));
    };
    LinkControlProtocol.prototype.handleEchoReply = function (identifier, data) {
        if (this.state !== ControlProtocol_1.ControlProtocolState.Opened)
            return;
        var reply;
        try {
            reply = MagicPlusData_1.default.parse(data);
        }
        catch (_a) {
            console.error('Error parsing Echo-Reply packet');
            return;
        }
        if (reply.magicNumber !== 0) {
            // The Magic-Number option is not implemented, so an
            // Echo-Reply packet MUST be transmitted with the
            // Magic-Number field set to zero. An Echo-Reply with
            // any other value must therefore be malformed.
            console.warn("Received malformed Echo-Reply packet: packet contains nonzero Magic-Number value 0x".concat(reply.magicNumber.toString(8)));
            return;
        }
        if (identifier != this.lastSentEchoRequestIdentifier ||
            Buffer.compare(reply.data, this.lastSentEchoRequestData) !== 0) {
            return;
        }
        if (this.pingPromiseResolve)
            this.pingPromiseResolve();
        this.resetPingTimer();
    };
    LinkControlProtocol.prototype.pingTimerExpired = function () {
        if (this.pingAttemptsRemaining > 0) {
            this.pingAttemptsRemaining -= 1;
            this.sendEchoRequest(Buffer.alloc(0));
            this.pingTimer = setTimeout(this.pingTimerExpired.bind(this), this.pingTimeout);
        }
        else {
            if (this.pingPromiseReject) {
                this.pingPromiseReject(new Error('Ping timed out'));
            }
            this.resetPingTimer();
        }
    };
    LinkControlProtocol.prototype.thisLayerUp = function () {
        this.emit('linkUp');
    };
    LinkControlProtocol.prototype.thisLayerDown = function () {
        if (this.pingTimer) {
            if (this.pingPromiseReject) {
                this.pingPromiseReject(new Error('Ping failed: layer down'));
            }
            this.resetPingTimer();
        }
        this.emit('linkDown');
    };
    LinkControlProtocol.prototype.thisLayerStarted = function () {
        this.emit('linkStarted');
    };
    LinkControlProtocol.prototype.thisLayerFinished = function () {
        this.emit('linkFinished');
    };
    return LinkControlProtocol;
}(ControlProtocol_1.default));
exports.default = LinkControlProtocol;
//# sourceMappingURL=LinkControlProtocol.js.map