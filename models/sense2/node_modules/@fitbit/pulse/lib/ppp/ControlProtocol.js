"use strict";
/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControlProtocolState = exports.ControlCode = void 0;
var tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-empty-function */
var events_1 = (0, tslib_1.__importDefault)(require("events"));
var LCPEncapsulation_1 = (0, tslib_1.__importDefault)(require("./LCPEncapsulation"));
var OptionList_1 = (0, tslib_1.__importDefault)(require("./OptionList"));
var event_1 = (0, tslib_1.__importDefault)(require("../util/event"));
// Code values shared by all Control Protocols
var ControlCode;
(function (ControlCode) {
    ControlCode[ControlCode["ConfigureRequest"] = 1] = "ConfigureRequest";
    ControlCode[ControlCode["ConfigureAck"] = 2] = "ConfigureAck";
    ControlCode[ControlCode["ConfigureNak"] = 3] = "ConfigureNak";
    ControlCode[ControlCode["ConfigureReject"] = 4] = "ConfigureReject";
    ControlCode[ControlCode["TerminateRequest"] = 5] = "TerminateRequest";
    ControlCode[ControlCode["TerminateAck"] = 6] = "TerminateAck";
    ControlCode[ControlCode["CodeReject"] = 7] = "CodeReject";
})(ControlCode = exports.ControlCode || (exports.ControlCode = {}));
var ControlProtocolState;
(function (ControlProtocolState) {
    ControlProtocolState["Initial"] = "initial";
    ControlProtocolState["Starting"] = "starting";
    ControlProtocolState["Closed"] = "closed";
    ControlProtocolState["Stopped"] = "stopped";
    ControlProtocolState["Closing"] = "closing";
    ControlProtocolState["Stopping"] = "stopping";
    ControlProtocolState["ReqSent"] = "req-sent";
    ControlProtocolState["AckRcvd"] = "ack-rcvd";
    ControlProtocolState["AckSent"] = "ack-sent";
    ControlProtocolState["Opened"] = "opened";
})(ControlProtocolState = exports.ControlProtocolState || (exports.ControlProtocolState = {}));
function ensureArray(items) {
    return Array.isArray(items) ? items : [items];
}
var ControlProtocol = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(ControlProtocol, _super);
    function ControlProtocol(displayName) {
        var _this = _super.call(this) || this;
        _this.displayName = displayName;
        _this.state = ControlProtocolState.Initial;
        _this.restartCount = 0;
        _this.configureRequestIdentifier = 255;
        _this.codeRejectIdentifier = 0;
        _this.lastSentConfigureOptions = Buffer.alloc(0);
        _this.lastSentConfigureRequest = Buffer.alloc(0);
        _this.configureFailCount = ControlProtocol.maxFailure;
        _this.isFinished = new event_1.default();
        // The lower layer is ready to carry packets.
        _this._up = _this.addStateTrigger([
            [ControlProtocolState.Initial, ControlProtocolState.Closed],
            {
                source: ControlProtocolState.Starting,
                dest: ControlProtocolState.ReqSent,
                before: ['initConfigureRestartCount', 'sendConfigureRequest'],
            },
        ]);
        // The lower layer is no longer available to carry packets.
        _this._down = _this.addStateTrigger([
            [ControlProtocolState.Closed, ControlProtocolState.Initial],
            {
                source: ControlProtocolState.Stopped,
                dest: ControlProtocolState.Starting,
                before: ['thisLayerStarted'],
            },
            [ControlProtocolState.Closing, ControlProtocolState.Initial],
            [
                [
                    ControlProtocolState.Stopping,
                    ControlProtocolState.ReqSent,
                    ControlProtocolState.AckRcvd,
                    ControlProtocolState.AckSent,
                ],
                ControlProtocolState.Starting,
            ],
            {
                source: ControlProtocolState.Opened,
                dest: ControlProtocolState.Starting,
                before: ['thisLayerDown'],
            },
        ]);
        // The link is administratively allowed to be opened.
        _this.open = _this.addStateTrigger([
            {
                source: ControlProtocolState.Initial,
                dest: ControlProtocolState.Starting,
                before: ['thisLayerStarted'],
            },
            [ControlProtocolState.Starting, ControlProtocolState.Starting],
            {
                source: ControlProtocolState.Closed,
                dest: ControlProtocolState.ReqSent,
                before: ['initConfigureRestartCount', 'sendConfigureRequest'],
            },
            [ControlProtocolState.Stopped, ControlProtocolState.Stopped],
            [ControlProtocolState.Closing, ControlProtocolState.Stopping],
            [ControlProtocolState.Stopping, ControlProtocolState.Stopping],
            [ControlProtocolState.ReqSent, ControlProtocolState.ReqSent],
            [ControlProtocolState.AckRcvd, ControlProtocolState.AckRcvd],
            [ControlProtocolState.AckSent, ControlProtocolState.AckSent],
            [ControlProtocolState.Opened, ControlProtocolState.Opened],
        ]);
        // The link is not allowed to be opened.
        _this.close = _this.addStateTrigger([
            [ControlProtocolState.Initial, ControlProtocolState.Initial],
            {
                source: ControlProtocolState.Starting,
                dest: ControlProtocolState.Initial,
                before: ['_thisLayerFinished'],
            },
            [ControlProtocolState.Closed, ControlProtocolState.Closed],
            [ControlProtocolState.Stopped, ControlProtocolState.Closed],
            [ControlProtocolState.Closing, ControlProtocolState.Closing],
            [ControlProtocolState.Stopping, ControlProtocolState.Closing],
            {
                source: [
                    ControlProtocolState.ReqSent,
                    ControlProtocolState.AckRcvd,
                    ControlProtocolState.AckSent,
                ],
                dest: ControlProtocolState.Closing,
                before: ['initTerminateRestartCount', 'sendTerminateRequest'],
            },
            {
                source: ControlProtocolState.Opened,
                dest: ControlProtocolState.Closing,
                before: [
                    'thisLayerDown',
                    'initTerminateRestartCount',
                    'sendTerminateRequest',
                ],
            },
        ]);
        // TO+ Event
        _this.timeoutRetry = _this.addStateTrigger([
            {
                source: ControlProtocolState.Closing,
                dest: ControlProtocolState.Closing,
                before: ['sendTerminateRequest'],
            },
            {
                source: ControlProtocolState.Stopping,
                dest: ControlProtocolState.Stopping,
                before: ['sendTerminateRequest'],
            },
            {
                source: [ControlProtocolState.ReqSent, ControlProtocolState.AckRcvd],
                dest: ControlProtocolState.ReqSent,
                before: ['retransmitConfigureRequest'],
            },
            {
                source: ControlProtocolState.AckSent,
                dest: ControlProtocolState.AckSent,
                before: ['retransmitConfigureRequest'],
            },
        ]);
        // TO- Event
        _this.timeoutGiveup = _this.addStateTrigger([
            {
                source: ControlProtocolState.Closing,
                dest: ControlProtocolState.Closed,
                before: ['_thisLayerFinished'],
            },
            {
                source: [
                    ControlProtocolState.Stopping,
                    ControlProtocolState.ReqSent,
                    ControlProtocolState.AckRcvd,
                    ControlProtocolState.AckSent,
                ],
                dest: ControlProtocolState.Stopped,
                before: ['_thisLayerFinished'],
            },
        ]);
        // RCR+ Event
        _this.receiveConfigureRequestAcceptable = _this.addStateTrigger([
            {
                source: ControlProtocolState.Closed,
                dest: ControlProtocolState.Closed,
                before: ['sendTerminateAck'],
            },
            {
                source: ControlProtocolState.Stopped,
                dest: ControlProtocolState.AckSent,
                before: [
                    'initConfigureRestartCount',
                    'sendConfigureRequest',
                    'sendConfigureAck',
                ],
            },
            [ControlProtocolState.Closing, ControlProtocolState.Closing],
            [ControlProtocolState.Stopping, ControlProtocolState.Stopping],
            {
                source: [ControlProtocolState.ReqSent, ControlProtocolState.AckSent],
                dest: ControlProtocolState.AckSent,
                before: ['sendConfigureAck'],
            },
            {
                source: ControlProtocolState.AckRcvd,
                dest: ControlProtocolState.Opened,
                before: ['sendConfigureAck'],
                after: ['thisLayerUp'],
            },
            {
                source: ControlProtocolState.Opened,
                dest: ControlProtocolState.AckSent,
                before: ['thisLayerDown', 'sendConfigureRequest', 'sendConfigureAck'],
            },
        ]);
        // RCR- Event
        _this.receiveConfigureRequestUnacceptable = _this.addStateTrigger([
            {
                source: ControlProtocolState.Closed,
                dest: ControlProtocolState.Closed,
                before: ['sendTerminateAck'],
            },
            {
                source: ControlProtocolState.Stopped,
                dest: ControlProtocolState.ReqSent,
                before: [
                    'initConfigureRestartCount',
                    'sendConfigureRequest',
                    'sendConfigureNakOrRej',
                ],
            },
            [ControlProtocolState.Closing, ControlProtocolState.Closing],
            [ControlProtocolState.Stopping, ControlProtocolState.Stopping],
            {
                source: [ControlProtocolState.ReqSent, ControlProtocolState.AckSent],
                dest: ControlProtocolState.ReqSent,
                before: ['sendConfigureNakOrRej'],
            },
            {
                source: ControlProtocolState.AckRcvd,
                dest: ControlProtocolState.AckRcvd,
                before: ['sendConfigureNakOrRej'],
            },
            {
                source: ControlProtocolState.Opened,
                dest: ControlProtocolState.ReqSent,
                before: [
                    'thisLayerDown',
                    'sendConfigureRequest',
                    'sendConfigureNakOrRej',
                ],
            },
        ]);
        // RCA Event
        _this.receiveConfigureAck = _this.addStateTrigger([
            {
                source: ControlProtocolState.Closed,
                dest: ControlProtocolState.Closed,
                before: ['sendTerminateAck'],
            },
            {
                source: ControlProtocolState.Stopped,
                dest: ControlProtocolState.Stopped,
                before: ['sendTerminateAck'],
            },
            [ControlProtocolState.Closing, ControlProtocolState.Closing],
            [ControlProtocolState.Stopping, ControlProtocolState.Stopping],
            {
                source: ControlProtocolState.ReqSent,
                dest: ControlProtocolState.AckRcvd,
                before: ['initConfigureRestartCount'],
            },
            {
                source: ControlProtocolState.AckRcvd,
                dest: ControlProtocolState.ReqSent,
                before: ['sendConfigureRequest'],
            },
            {
                source: ControlProtocolState.AckSent,
                dest: ControlProtocolState.Opened,
                before: ['initConfigureRestartCount'],
                after: ['thisLayerUp'],
            },
            {
                source: ControlProtocolState.Opened,
                dest: ControlProtocolState.ReqSent,
                before: ['thisLayerDown', 'sendConfigureRequest'],
            },
        ]);
        // RCN Event
        _this.receiveConfigureNakOrRej = _this.addStateTrigger([
            {
                source: ControlProtocolState.Closed,
                dest: ControlProtocolState.Closed,
                before: ['sendTerminateAck'],
            },
            {
                source: ControlProtocolState.Stopped,
                dest: ControlProtocolState.Stopped,
                before: ['sendTerminateAck'],
            },
            [ControlProtocolState.Closing, ControlProtocolState.Closing],
            [ControlProtocolState.Stopping, ControlProtocolState.Stopping],
            {
                source: ControlProtocolState.ReqSent,
                dest: ControlProtocolState.ReqSent,
                before: ['initConfigureRestartCount', 'sendConfigureRequest'],
            },
            {
                source: ControlProtocolState.AckRcvd,
                dest: ControlProtocolState.ReqSent,
                before: ['sendConfigureRequest'],
            },
            {
                source: ControlProtocolState.AckSent,
                dest: ControlProtocolState.AckSent,
                before: ['initConfigureRestartCount', 'sendConfigureRequest'],
            },
            {
                source: ControlProtocolState.Opened,
                dest: ControlProtocolState.ReqSent,
                before: ['thisLayerDown', 'sendConfigureRequest'],
            },
        ]);
        // RTR Event
        _this.receiveTerminateRequest = _this.addStateTrigger([
            {
                source: ControlProtocolState.Closed,
                dest: ControlProtocolState.Closed,
                before: ['sendTerminateAck'],
            },
            {
                source: ControlProtocolState.Stopped,
                dest: ControlProtocolState.Stopped,
                before: ['sendTerminateAck'],
            },
            {
                source: ControlProtocolState.Closing,
                dest: ControlProtocolState.Closing,
                before: ['sendTerminateAck'],
            },
            {
                source: ControlProtocolState.Stopping,
                dest: ControlProtocolState.Stopping,
                before: ['sendTerminateAck'],
            },
            {
                source: [
                    ControlProtocolState.ReqSent,
                    ControlProtocolState.AckRcvd,
                    ControlProtocolState.AckSent,
                ],
                dest: ControlProtocolState.ReqSent,
                before: ['sendTerminateAck'],
            },
            {
                source: ControlProtocolState.Opened,
                dest: ControlProtocolState.Stopping,
                before: ['thisLayerDown', 'zeroRestartCount', 'sendTerminateAck'],
            },
        ]);
        // RTA Event
        _this.receiveTerminateAck = _this.addStateTrigger([
            [ControlProtocolState.Closed, ControlProtocolState.Closed],
            [ControlProtocolState.Stopped, ControlProtocolState.Stopped],
            {
                source: ControlProtocolState.Closing,
                dest: ControlProtocolState.Closed,
                before: ['_thisLayerFinished'],
            },
            {
                source: ControlProtocolState.Stopping,
                dest: ControlProtocolState.Stopped,
                before: ['_thisLayerFinished'],
            },
            [
                [ControlProtocolState.ReqSent, ControlProtocolState.AckRcvd],
                ControlProtocolState.ReqSent,
            ],
            {
                source: ControlProtocolState.Opened,
                dest: ControlProtocolState.ReqSent,
                before: ['thisLayerDown', 'sendConfigureRequest'],
            },
        ]);
        // The RUC event is intentionally left out of the state table.
        // Since that event never triggers a state transition, it is
        // handled as a special case in the code.
        // RXJ+ Event
        _this.receiveCodeRejectPermitted = _this.addStateTrigger([
            [ControlProtocolState.Closed, ControlProtocolState.Closed],
            [ControlProtocolState.Stopped, ControlProtocolState.Stopped],
            [ControlProtocolState.Closing, ControlProtocolState.Closing],
            [ControlProtocolState.Stopping, ControlProtocolState.Stopping],
            [
                [ControlProtocolState.ReqSent, ControlProtocolState.AckRcvd],
                ControlProtocolState.ReqSent,
            ],
            [ControlProtocolState.AckSent, ControlProtocolState.AckSent],
            [ControlProtocolState.Opened, ControlProtocolState.Opened],
        ]);
        // RXJ- Event
        _this.receiveCodeRejectCatastrophic = _this.addStateTrigger([
            {
                source: [ControlProtocolState.Closed, ControlProtocolState.Closing],
                dest: ControlProtocolState.Closed,
                before: ['_thisLayerFinished'],
            },
            {
                source: [
                    ControlProtocolState.Stopped,
                    ControlProtocolState.Stopping,
                    ControlProtocolState.ReqSent,
                    ControlProtocolState.AckRcvd,
                    ControlProtocolState.AckSent,
                ],
                dest: ControlProtocolState.Stopped,
                before: ['_thisLayerFinished'],
            },
            {
                source: ControlProtocolState.Opened,
                dest: ControlProtocolState.Stopping,
                before: [
                    'thisLayerDown',
                    'initTerminateRestartCount',
                    'sendTerminateRequest',
                ],
            },
        ]);
        return _this;
    }
    ControlProtocol.prototype.maybeStopRestartTimer = function () {
        if ([
            ControlProtocolState.Initial,
            ControlProtocolState.Starting,
            ControlProtocolState.Closed,
            ControlProtocolState.Stopped,
            ControlProtocolState.Opened,
        ].includes(this.state)) {
            this.stopRestartTimer();
        }
    };
    ControlProtocol.prototype.handleEventCallback = function (cb, args) {
        // Sorry typings... :(
        var func = this[cb];
        func.call.apply(func, (0, tslib_1.__spreadArray)([this], (0, tslib_1.__read)(args), false));
    };
    ControlProtocol.prototype.addStateTrigger = function (transitions) {
        var _this = this;
        return function () {
            var e_1, _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                for (var transitions_1 = (0, tslib_1.__values)(transitions), transitions_1_1 = transitions_1.next(); !transitions_1_1.done; transitions_1_1 = transitions_1.next()) {
                    var transition = transitions_1_1.value;
                    if (Array.isArray(transition)) {
                        var _b = (0, tslib_1.__read)(transition, 2), sources = _b[0], dest = _b[1];
                        if (ensureArray(sources).includes(_this.state)) {
                            _this.state = dest;
                            _this.maybeStopRestartTimer();
                            break;
                        }
                    }
                    else {
                        var source = transition.source, dest = transition.dest, before = transition.before, after = transition.after;
                        if (ensureArray(source).includes(_this.state)) {
                            if (before)
                                before.forEach(function (cb) { return _this.handleEventCallback(cb, args); });
                            _this.state = dest;
                            if (after)
                                after.forEach(function (cb) { return _this.handleEventCallback(cb, args); });
                            _this.maybeStopRestartTimer();
                            break;
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (transitions_1_1 && !transitions_1_1.done && (_a = transitions_1.return)) _a.call(transitions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
    };
    // There are no transitions for RXR events because none of the
    // packets which trigger that event are supported by the base
    // Control Protocol state machine.
    ControlProtocol.prototype.restart = function () {
        this._down();
        this._up();
    };
    ControlProtocol.prototype.up = function (socket) {
        this.socket = socket;
        socket.on('data', this.packetReceived.bind(this));
        socket.on('close', this.down.bind(this));
        this._up();
    };
    ControlProtocol.prototype.down = function () {
        this._down();
        if (this.socket) {
            this.socket.close();
            this.socket = undefined;
        }
    };
    /*
      Gracefully close the link, returning a Promise that resolves when
      the link is closed.
    */
    ControlProtocol.prototype.shutdown = function () {
        if ([
            ControlProtocolState.Initial,
            ControlProtocolState.Starting,
            ControlProtocolState.Closed,
            ControlProtocolState.Stopped,
        ].includes(this.state)) {
            return Promise.resolve();
        }
        this.close();
        return this.isFinished.wait().then();
    };
    ControlProtocol.prototype.isOpened = function () {
        return this.state === ControlProtocolState.Opened;
    };
    ControlProtocol.prototype.getCodeRejectIdentifier = function () {
        var identifier = this.codeRejectIdentifier;
        this.codeRejectIdentifier = (this.codeRejectIdentifier + 1) % 256;
        return identifier;
    };
    ControlProtocol.prototype.getConfigureRequestIdentifier = function () {
        this.configureRequestIdentifier =
            (this.configureRequestIdentifier + 1) % 256;
        return this.configureRequestIdentifier;
    };
    // Restart timer
    ControlProtocol.prototype.startRestartTimer = function (timeout) {
        this.stopRestartTimer();
        this.restartTimer = setTimeout(this.restartTimerExpired.bind(this), timeout);
    };
    ControlProtocol.prototype.stopRestartTimer = function () {
        if (this.restartTimer !== undefined) {
            clearTimeout(this.restartTimer);
            this.restartTimer = undefined;
        }
    };
    ControlProtocol.prototype.decrementAndStartRestartTimer = function () {
        this.restartCount -= 1;
        if (this.restartCount < 0) {
            /* istanbul ignore next */
            throw new Error('assert failed: restartCount >= 0');
        }
        this.startRestartTimer(ControlProtocol.restartTimeout);
    };
    ControlProtocol.prototype.restartTimerExpired = function () {
        if (this.restartCount > 0) {
            this.timeoutRetry();
        }
        else {
            this.timeoutGiveup();
        }
    };
    // Actions
    /*
      Signal to upper layers that the automaton is entering the Opened state.
  
      Subclasses should override this method.
    */
    ControlProtocol.prototype.thisLayerUp = function () { };
    /*
      Signal to upper layers that the automaton is leaving the Opened state.
  
      Subclasses should override this method.
    */
    ControlProtocol.prototype.thisLayerDown = function () { };
    /*
      Signal to lower layers that the automaton is entering the
      Starting state and that the lower layer is needed for the link.
  
      Subclasses should override this method.
    */
    ControlProtocol.prototype.thisLayerStarted = function () { };
    /*
      Signal to lower layers that the lower layer is no longer needed for the link.
  
      Subclasses should override this method.
    */
    ControlProtocol.prototype.thisLayerFinished = function () { };
    /*
      Send a packet out to the lower layer.
    */
    ControlProtocol.prototype.sendPacket = function (packet) {
        var _a;
        (_a = this.socket) === null || _a === void 0 ? void 0 : _a.send(packet);
    };
    // Actions handled internally
    ControlProtocol.prototype._thisLayerFinished = function () {
        this.isFinished.set();
        // duplicated because in py there's an event triggered here manually, TODO remove?
        this.thisLayerFinished();
    };
    ControlProtocol.prototype.initConfigureRestartCount = function () {
        this.restartCount = ControlProtocol.maxConfigure;
    };
    ControlProtocol.prototype.initTerminateRestartCount = function () {
        this.restartCount = ControlProtocol.maxTerminate;
    };
    ControlProtocol.prototype.zeroRestartCount = function () {
        this.restartCount = 0;
        this.startRestartTimer(ControlProtocol.restartTimeout);
    };
    ControlProtocol.prototype.sendConfigureRequest = function () {
        this.decrementAndStartRestartTimer();
        var options = OptionList_1.default.build(this.getConfigureRequestOptions());
        var packet = LCPEncapsulation_1.default.build(ControlCode.ConfigureRequest, this.getConfigureRequestIdentifier(), options);
        this.lastSentConfigureOptions = options;
        this.lastSentConfigureRequest = packet;
        this.sendPacket(packet);
    };
    ControlProtocol.prototype.retransmitConfigureRequest = function () {
        this.decrementAndStartRestartTimer();
        this.sendPacket(this.lastSentConfigureRequest);
    };
    ControlProtocol.prototype.sendConfigureAck = function (identifier, _a) {
        var options = _a.options;
        this.sendPacket(LCPEncapsulation_1.default.build(ControlCode.ConfigureAck, identifier, OptionList_1.default.build(options.map(function (_a) {
            var type = _a.type, data = _a.data;
            return [type, data];
        }))));
    };
    ControlProtocol.prototype.sendConfigureNakOrRej = function () {
        if (this.configureFailCount > 0) {
            throw new Error('Configure NAK/REJ not implemented');
        }
        // TODO convert nak to reject; strip out locally-desired
        // options.
        // FIXME find an appropriate place to reinitialize the fail
        // count.
    };
    ControlProtocol.prototype.sendTerminateRequest = function () {
        this.decrementAndStartRestartTimer();
        // FIXME: identifier
        this.sendPacket(LCPEncapsulation_1.default.build(ControlCode.TerminateRequest, 42));
    };
    ControlProtocol.prototype.sendTerminateAck = function () {
        // FIXME: identifier
        this.sendPacket(LCPEncapsulation_1.default.build(ControlCode.TerminateAck, 42));
    };
    ControlProtocol.prototype.sendCodeReject = function (packet) {
        // Truncate rejected_packet to fit within the link MTU
        var maxLength = ControlProtocol.mtu - LCPEncapsulation_1.default.headerSize;
        if (maxLength <= 0) {
            // TODO: add test
            throw new Error('Cannot truncate rejected packet to fit within MTU');
        }
        var truncatedPacket = packet.slice(0, maxLength + 1);
        this.sendPacket(LCPEncapsulation_1.default.build(ControlCode.CodeReject, this.getCodeRejectIdentifier(), truncatedPacket));
    };
    // Events not handled by the state table
    /*
      The lower layer must call this method whenever a packet
      is received which is addressed to this protocol.
  
      The packet must already have any lower layer headers (including
      the protocol number) removed.
    */
    ControlProtocol.prototype.packetReceived = function (packet) {
        if (this.state === ControlProtocolState.Initial ||
            this.state === ControlProtocolState.Starting) {
            console.warn("Received unexpected packet in state ".concat(this.state));
        }
        var encapsulation;
        try {
            encapsulation = LCPEncapsulation_1.default.parse(packet);
        }
        catch (_a) {
            console.warn('Packet parsing failed');
            return;
        }
        var code;
        if (!Object.values(ControlCode).includes(encapsulation.code)) {
            var handled = this.handleUnknownCode(encapsulation.code, encapsulation.identifier, encapsulation.data);
            if (!handled)
                this.sendCodeReject(packet);
            return;
        }
        else {
            code = encapsulation.code;
        }
        if ([
            ControlCode.ConfigureRequest,
            ControlCode.ConfigureAck,
            ControlCode.ConfigureNak,
            ControlCode.ConfigureReject,
        ].includes(code)) {
            if ([ControlProtocolState.Closing, ControlProtocolState.Stopping].includes(this.state)) {
                // Waiting for Terminate-Ack; ignoring configure requests.
                return;
            }
            var options = void 0;
            try {
                options = OptionList_1.default.parse(encapsulation.data);
            }
            catch (_b) {
                console.error('Parsing option list failed');
                return;
            }
            if (code === ControlCode.ConfigureRequest) {
                this.handleConfigureRequest(encapsulation.identifier, options);
            }
            else {
                if (encapsulation.identifier !== this.configureRequestIdentifier) {
                    // Invalid packet; silently discard
                    console.warn("Received response packet with mismatched identifier: expected ".concat(this.configureRequestIdentifier, " received: ").concat(encapsulation.identifier));
                    return;
                }
                else if (code === ControlCode.ConfigureAck) {
                    if (Buffer.compare(encapsulation.data, this.lastSentConfigureOptions) === 0) {
                        this.receiveConfigureAck(options);
                    }
                    else {
                        console.error('Received Configure-Ack with mismatched options');
                        return;
                    }
                }
                else if (code === ControlCode.ConfigureNak) {
                    this.handleConfigureNak(options);
                    this.receiveConfigureNakOrRej();
                }
                else if (code === ControlCode.ConfigureReject) {
                    this.handleConfigureReject(options);
                    this.receiveConfigureNakOrRej();
                }
                else {
                    /* istanbul ignore next */
                    throw new Error('PPP machine reached impossible state');
                }
            }
        }
        else if (code === ControlCode.TerminateRequest) {
            this.receiveTerminateRequest();
        }
        else if (code === ControlCode.TerminateAck) {
            this.receiveTerminateAck();
        }
        else if (code === ControlCode.CodeReject) {
            var rejectedPacket = void 0;
            try {
                rejectedPacket = LCPEncapsulation_1.default.parse(encapsulation.data);
            }
            catch (_c) {
                console.error('Error parsing Code-Reject response');
                return;
            }
            if (Object.values(ControlCode).includes(rejectedPacket.code)) {
                console.error("Remote peer rejected a packet with code ".concat(rejectedPacket.code, "; the connection cannot proceed without this code being supported"));
                this.receiveCodeRejectCatastrophic();
            }
            else {
                var isCatestrophic = this.handleCodeReject(rejectedPacket);
                if (isCatestrophic) {
                    console.error('Remote peer rejected a packet which must be supported for the connection to proceeed');
                    this.receiveCodeRejectCatastrophic();
                }
            }
        }
        else {
            /* istanbul ignore next */
            throw new Error('PPP machine did not handle known code');
        }
    };
    ControlProtocol.prototype.handleConfigureRequest = function (identifier, options) {
        var response = this.handleIncomingConfigureRequest(options);
        if (response) {
            this.receiveConfigureRequestAcceptable(identifier, options);
        }
        else {
            // TODO assert that the response options have not been reordered.
            this.receiveConfigureRequestUnacceptable(identifier, options);
        }
    };
    /*
      Implementations will need to parse the options list and
      determine if the options are acceptable.
  
      If the complete set of options are acceptable, the
      implementation must configure itself according to the options,
      then return `true`.
  
      If any of the options are unrecognizable, the implementation
      must return an instance of `OptionList` containing
      all of the options that were not recognized, in the same order
      that they were received.
  
      If all of the options are recognized but contain unacceptable
      values, or if the implementation wants to request the
      negotiation of an option which the sender of the configuration
      request did not include, the implementation must return an
      instance of `ConfigurationNak` containing the options list that
      should be sent in a Configure-Nak packet (all acceptable options
      filtered out).
    */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ControlProtocol.prototype.handleIncomingConfigureRequest = function (options) {
        // TODO: match to description above
        return options.options.length === 0 ? true : options;
    };
    // Negotiation of outgoing options (configure remote peer)
    /*
      Return the list of Options to be sent to the remote peer in
      the next Configure-Request packet.
    */
    ControlProtocol.prototype.getConfigureRequestOptions = function () {
        return [];
    };
    /*
      Handle options that were rejected by the remote peer.
      Implementations must keep track of state so that the next call
      to `getConfigureRequestOptions` will reflect the rejected
      options.
  
      TODO: If the session cannot proceed because an option was rejected
      which the implementation requires be negotiated,
      `NegotiationFailure` should be raised.
    */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ControlProtocol.prototype.handleConfigureReject = function (unacceptableOptions) {
        // pass
    };
    /*
      Handle options which were not acceptable by the remote peer.
      Implementations must update their configuration state so that
      the next call to `getConfigureRequestOptions` will
      reflect the values that the remote peer has deemed unacceptable.
    */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ControlProtocol.prototype.handleConfigureNak = function (unacceptableOptions) {
        // pass
    };
    /*
      Handle the remote peer accepting the options list.
    */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ControlProtocol.prototype.handleConfigureAccepted = function (options) {
        // pass
    };
    /* Returns `true` if the code is handled, otherwise `false` */
    ControlProtocol.prototype.handleUnknownCode = function (
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    code, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    identifier, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    data) {
        return false;
    };
    /*
      Handle a Code-Reject packet received from the peer containing
      a code which the base control protocol implementation does not
      recognize.
  
      Return `true` if a rejection of that code
      cannot be recovered from, otherwise `false`.
    */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ControlProtocol.prototype.handleCodeReject = function (rejectedPacket) {
        return false;
    };
    /* The number of Terminate-Request packets sent without receiving a
    Terminate-Ack before assuming that the peer is unable to respond. */
    ControlProtocol.maxTerminate = 2;
    /* Number of Configure-Request packets sent without receiving a
    valid Configure-Ack, Configure-Nak or Configure-Reject before
    assuming that the peer is unable to respond. */
    ControlProtocol.maxConfigure = 10;
    /* Number of Configure-Nak packets sent without sending a
    Configure-Ack before assuming that configuration is not
    converging. */
    ControlProtocol.maxFailure = 5;
    /* Restart timer expiry duration, in milliseconds. */
    ControlProtocol.restartTimeout = 4000;
    /* TODO: proper MTU/MRU support */
    ControlProtocol.mtu = 1500;
    return ControlProtocol;
}(events_1.default));
exports.default = ControlProtocol;
//# sourceMappingURL=ControlProtocol.js.map