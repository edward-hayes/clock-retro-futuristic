"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HostConnection = void 0;
const tslib_1 = require("tslib");
require("stream.finished/auto");
const fdb_debugger_1 = require("@fitbit/fdb-debugger");
const dateformat_1 = tslib_1.__importDefault(require("dateformat"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const stream_1 = tslib_1.__importDefault(require("stream"));
const ts_events_1 = require("ts-events");
const developerRelay = tslib_1.__importStar(require("../api/developerRelay"));
const USBDebugHost = tslib_1.__importStar(require("./USBDebugHost"));
const StreamTap_1 = tslib_1.__importDefault(require("./StreamTap"));
class HostConnection {
    constructor(stream, host) {
        this.stream = stream;
        this.host = host;
    }
    static getDumpStreamTap() {
        const shouldDumpLogFile = process.env.FITBIT_DEVBRIDGE_DUMP === '1';
        if (!shouldDumpLogFile)
            return undefined;
        const dumpLogFilePath = (0, dateformat_1.default)('"log" yyyy-mm-dd "at" H.MM.ss."txt"');
        const dumpLogFileHandle = fs_1.default.openSync(dumpLogFilePath, 'w');
        const now = () => new Date().getTime();
        const epoch = now();
        function writeChunk(prefix) {
            return (chunk) => fs_1.default.writeSync(dumpLogFileHandle, `[${prefix}][${now() - epoch}] ${JSON.stringify(chunk, undefined, 2)}\n`);
        }
        const transforms = {
            preSerializeTransform: new StreamTap_1.default(writeChunk('send')),
            postDeserializeTransform: new StreamTap_1.default(writeChunk('recv')),
        };
        stream_1.default.finished(transforms.postDeserializeTransform, () => fs_1.default.closeSync(dumpLogFileHandle));
        return transforms;
    }
    static async connect(stream) {
        return new this(stream, await fdb_debugger_1.RemoteHost.connect(stream, this.getDumpStreamTap()));
    }
}
exports.HostConnection = HostConnection;
class HostConnections {
    constructor() {
        this.onHostAdded = new ts_events_1.SyncEvent();
    }
    async connect(host, deviceType) {
        const hostTypes = {
            device: 'appHost',
            phone: 'companionHost',
        };
        const hostType = hostTypes[deviceType];
        const existingHost = this[hostType];
        if (existingHost)
            existingHost.stream.destroy();
        const stream = await host.connect();
        let hostConnection;
        try {
            hostConnection = await HostConnection.connect(stream);
        }
        catch (ex) {
            stream.destroy();
            throw ex;
        }
        this[hostType] = hostConnection;
        this.onHostAdded.post({ hostType, host: hostConnection.host });
        return hostConnection;
    }
    async listOfType(deviceType) {
        const hosts = [];
        try {
            for (const device of await developerRelay.hosts()) {
                hosts.push(device);
            }
        }
        catch (error) {
            throw new Error(`An error was encountered when loading the list of available Developer Relay hosts: ${error.message}`);
        }
        if (deviceType === 'device') {
            try {
                for (const device of await USBDebugHost.list()) {
                    hosts.push(device);
                }
            }
            catch (error) {
                throw new Error(`An error was encountered when loading the list of available USB hosts: ${error.message}`);
            }
        }
        const hostRole = {
            device: 'APP_HOST',
            phone: 'COMPANION_HOST',
        }[deviceType];
        return hosts.filter((host) => host.roles.includes(hostRole));
    }
}
exports.default = HostConnections;
//# sourceMappingURL=HostConnections.js.map