"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const os_1 = tslib_1.__importDefault(require("os"));
const stream_1 = require("stream");
const util_1 = require("util");
const usb_1 = require("usb");
const FITBIT_VENDOR_ID = 0x2687;
const FITBIT_FDB_INTERFACE_NAME = 'CDC-FDB';
const openedDevices = new Set();
function findEndpoint(endpoints, direction) {
    const epTypeMask = 0x03;
    for (const endpoint of endpoints) {
        const epDirection = endpoint.bEndpointAddress & usb_1.usb.LIBUSB_ENDPOINT_IN ? 'in' : 'out';
        const epType = endpoint.bmAttributes & epTypeMask;
        if (direction === epDirection && epType === usb_1.usb.LIBUSB_TRANSFER_TYPE_BULK) {
            return endpoint.bEndpointAddress;
        }
    }
}
function getStringDescriptor(device, id) {
    return new Promise((resolve, reject) => {
        device.getStringDescriptor(id, (ex, value) => {
            if (ex)
                reject(ex);
            else
                resolve(value);
        });
    });
}
async function findDeviceEndpoints(device) {
    if (!openedDevices.has(device))
        device.open();
    try {
        const { allConfigDescriptors, deviceDescriptor } = device;
        const { iProduct } = deviceDescriptor;
        const productName = await getStringDescriptor(device, iProduct);
        for (const { bConfigurationValue, interfaces } of allConfigDescriptors) {
            let lastInterfaceName;
            for (const interfaceDescriptors of interfaces) {
                for (const { bInterfaceNumber, iInterface, endpoints, } of interfaceDescriptors) {
                    const interfaceName = await getStringDescriptor(device, iInterface);
                    if (interfaceName)
                        lastInterfaceName = interfaceName;
                    if (lastInterfaceName !== FITBIT_FDB_INTERFACE_NAME)
                        continue;
                    const writeEndpoint = findEndpoint(endpoints, 'out');
                    const readEndpoint = findEndpoint(endpoints, 'in');
                    if (writeEndpoint !== undefined &&
                        readEndpoint !== undefined &&
                        productName !== undefined) {
                        return {
                            writeEndpoint,
                            readEndpoint,
                            interface: bInterfaceNumber,
                            configuration: bConfigurationValue,
                            name: productName,
                        };
                    }
                }
            }
        }
    }
    finally {
        if (!openedDevices.has(device))
            device.close();
    }
}
class USBSerialDevice extends stream_1.Duplex {
    constructor(device, intf, readEndpoint, writeEndpoint) {
        super();
        this.device = device;
        this.intf = intf;
        this.readEndpoint = readEndpoint;
        this.writeEndpoint = writeEndpoint;
        this.transfers = new Set();
        this.handleDisconnect = (removedDevice) => {
            if (this.device === removedDevice) {
                this.destroy();
            }
        };
        usb_1.usb.on('detach', this.handleDisconnect);
        this.on('close', () => void this.cleanup());
    }
    static async create(device, config) {
        var _a;
        try {
            openedDevices.add(device);
            if (((_a = device.configDescriptor) === null || _a === void 0 ? void 0 : _a.bConfigurationValue) === config.configuration) {
                device.open();
            }
            else {
                device.open(false);
                const setConfigurationFunc = (0, util_1.promisify)(device.setConfiguration).bind(device);
                await setConfigurationFunc(config.configuration);
            }
            const intf = device.interface(config.interface);
            if (os_1.default.type() === 'Linux' && intf.isKernelDriverActive()) {
                intf.detachKernelDriver();
            }
            intf.claim();
            const readEndpoint = intf.endpoint(config.readEndpoint);
            const writeEndpoint = intf.endpoint(config.writeEndpoint);
            return new USBSerialDevice(device, intf, readEndpoint, writeEndpoint);
        }
        catch (ex) {
            openedDevices.delete(device);
            device.close();
            throw ex;
        }
    }
    static async list() {
        const usbDevices = usb_1.usb.getDeviceList();
        const fitbitDevices = [];
        for (const usbDevice of usbDevices) {
            const { deviceDescriptor } = usbDevice;
            if (deviceDescriptor.idVendor !== FITBIT_VENDOR_ID)
                continue;
            const deviceEndpoints = await findDeviceEndpoints(usbDevice);
            if (deviceEndpoints) {
                fitbitDevices.push({
                    name: deviceEndpoints.name,
                    get opened() {
                        return openedDevices.has(usbDevice);
                    },
                    connect: () => USBSerialDevice.create(usbDevice, deviceEndpoints),
                });
            }
        }
        return fitbitDevices;
    }
    async cleanup() {
        usb_1.usb.off('detach', this.handleDisconnect);
        this.transfers.forEach((transfer) => transfer.cancel());
        this.transfers.clear();
        try {
            const releaseFunc = (0, util_1.promisify)(this.intf.release).bind(this.intf, true);
            await releaseFunc();
            this.device.close();
            openedDevices.delete(this.device);
        }
        catch (ex) {
            const msg = `Failed to close USB device: ${String(ex)}`;
            console.warn(msg);
            this.emit('error', new Error(msg));
        }
    }
    _read(size) {
        const buffer = Buffer.alloc(Math.min(size, this.readEndpoint.descriptor.wMaxPacketSize));
        const transfer = this.readEndpoint.makeTransfer(0, (ex, buffer, bytesRead) => {
            if (ex) {
                this.emit('error', new Error(`USB read failed: ${String(ex)}`));
                return;
            }
            this.push(buffer.slice(0, bytesRead));
        });
        transfer.submit(buffer);
        this.transfers.add(transfer);
    }
    _write(chunk, encoding, callback) {
        const transfer = this.writeEndpoint.makeTransfer(0, (ex, buffer, bytesWritten) => {
            if (ex) {
                callback(new Error(`USB write failed: ${String(ex)}`));
                return;
            }
            if (bytesWritten === chunk.byteLength) {
                callback();
            }
            else {
                callback(new Error(`USB write failed: wrote ${bytesWritten} of ${chunk.byteLength} bytes`));
            }
        });
        transfer.submit(chunk);
        this.transfers.add(transfer);
    }
}
exports.default = USBSerialDevice;
//# sourceMappingURL=USBSerialDevice.js.map