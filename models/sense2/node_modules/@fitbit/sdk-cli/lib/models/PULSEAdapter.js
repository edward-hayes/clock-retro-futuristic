"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
const pulse_1 = require("@fitbit/pulse");
const DEVBRIDGE_HEADER_SIZE = 2;
const DEVBRIDGE_PORT = 0x3e20;
class PULSEAdapter extends stream_1.Duplex {
    constructor(intf, socket) {
        super({ objectMode: true });
        this.intf = intf;
        this.socket = socket;
        this.rxBuffer = Buffer.alloc(0);
        this.on('close', () => void this.intf.close());
        this.socket.on('close', () => this.destroy());
        socket.on('data', (packet) => {
            if (packet.byteLength < DEVBRIDGE_HEADER_SIZE) {
                this.emit('error', new Error(`Packet with length below minimum allowed`));
                return;
            }
            const [type, packetsFollowing] = new Uint8Array(packet);
            if (type !== 0)
                return;
            if (this.lastPacketsRemaining === undefined) {
                this.lastPacketsRemaining = packetsFollowing;
            }
            else if (this.lastPacketsRemaining !== packetsFollowing + 1) {
                const expected = this.lastPacketsRemaining - 1;
                this.emit('error', new Error(`Received out of sequence packet, expected ${expected}, got ${packetsFollowing}`));
            }
            else {
                this.lastPacketsRemaining -= 1;
            }
            this.rxBuffer = Buffer.concat([
                this.rxBuffer,
                packet.slice(DEVBRIDGE_HEADER_SIZE),
            ]);
            if (packetsFollowing === 0) {
                this.push(this.rxBuffer);
                this.rxBuffer = Buffer.alloc(0);
                this.lastPacketsRemaining = undefined;
            }
        });
    }
    static async create(stream) {
        const intf = pulse_1.Interface.create(stream, {
            requestedTransports: ['reliable'],
        });
        const link = await intf.getLink();
        const socket = await link.openSocket('reliable', DEVBRIDGE_PORT);
        return new PULSEAdapter(intf, socket);
    }
    _read() {
    }
    _write(buf, encoding, callback) {
        try {
            const chunkSize = this.socket.mtu - DEVBRIDGE_HEADER_SIZE;
            let bytesSent = 0;
            let chunksLeft = Math.ceil(buf.byteLength / chunkSize);
            while (chunksLeft > 0) {
                const body = buf.slice(bytesSent, bytesSent + chunkSize);
                chunksLeft -= 1;
                bytesSent += body.byteLength;
                const header = new Uint8Array([
                    0,
                    chunksLeft,
                ]);
                this.socket.send(Buffer.concat([header, body]));
            }
            callback();
        }
        catch (ex) {
            callback(ex);
        }
    }
}
exports.default = PULSEAdapter;
//# sourceMappingURL=PULSEAdapter.js.map