"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const dateformat_1 = tslib_1.__importDefault(require("dateformat"));
const untildify_1 = tslib_1.__importDefault(require("untildify"));
const captureHeapSnapshot_1 = tslib_1.__importDefault(require("../models/captureHeapSnapshot"));
const compatibility = tslib_1.__importStar(require("../models/compatibility"));
function heapSnapshot(stores) {
    return (cli) => {
        cli
            .command('heap-snapshot [path]', 'Capture a JS heap snapshot from the connected device and write the data to a file (experimental)')
            .option('-f, --format <fmt>', 'heap snapshot format to request', () => {
            if (!stores.hostConnections.appHost)
                return [];
            return [
                ...stores.hostConnections.appHost.host.getHeapSnapshotSupport()
                    .formats,
                'v8',
            ];
        })
            .types({ string: ['f', 'format', 'path'] })
            .action(async (args) => {
            const { appHost } = stores.hostConnections;
            if (!appHost) {
                cli.activeCommand.log('Not connected to a device');
                return false;
            }
            const { appPackage } = stores.appContext;
            if (!appPackage) {
                cli.activeCommand.log('App package not loaded, use `install` or `set-app-package` commands first');
                return false;
            }
            const { supported, formats } = appHost.host.getHeapSnapshotSupport();
            const snapshotFormats = ['v8', ...formats];
            if (!supported) {
                cli.activeCommand.log('Device does not support capturing JS heap snapshots');
                return false;
            }
            let { format } = args.options;
            if (!format) {
                if (snapshotFormats.length === 0) {
                    cli.activeCommand.log('Device does not support any heap snapshot formats');
                    return false;
                }
                if (snapshotFormats.length === 1) {
                    format = formats[0];
                    cli.activeCommand.log(`Requesting a JS heap snapshot in ${JSON.stringify(format)} format`);
                }
                else {
                    format = (await cli.activeCommand.prompt({
                        type: 'list',
                        name: 'format',
                        message: 'Which format would you like the JS heap snapshot to be in?',
                        choices: snapshotFormats,
                    })).format;
                }
            }
            const extension = format === 'v8' ? 'heapsnapshot' : 'bin';
            const destPath = path.resolve(args.path
                ? (0, untildify_1.default)(args.path)
                : (0, dateformat_1.default)(`"js-heap." yyyy-mm-dd.H.MM.ss."${extension}"`));
            let sourceMaps;
            if (appPackage.sourceMaps !== undefined &&
                appPackage.sourceMaps.device) {
                const deviceFamily = compatibility.findCompatibleAppComponent(appPackage, appHost.host.info);
                sourceMaps = appPackage.sourceMaps.device[deviceFamily];
            }
            try {
                await (0, captureHeapSnapshot_1.default)(appHost.host, format, destPath, appPackage.uuid, sourceMaps);
                cli.activeCommand.log(`JS heap snapshot saved to ${destPath}`);
                return true;
            }
            catch (ex) {
                cli.activeCommand.log(String(ex));
                return false;
            }
        });
    };
}
exports.default = heapSnapshot;
//# sourceMappingURL=heapSnapshot.js.map