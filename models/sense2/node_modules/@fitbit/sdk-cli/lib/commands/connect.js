"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.connectAction = void 0;
const lodash_1 = require("lodash");
const connectAction = async (cli, deviceType, hostConnections) => {
    let host;
    let availableHosts;
    try {
        const matchedHosts = await hostConnections.listOfType(deviceType);
        availableHosts = matchedHosts.filter((host) => host.available);
    }
    catch (ex) {
        cli.log(`An error was encountered when loading the list of available ${deviceType} hosts: ${ex.message}`);
        return false;
    }
    if (availableHosts.length === 0) {
        cli.activeCommand.log(`No ${deviceType}s are connected and available`);
        return false;
    }
    if (availableHosts.length === 1) {
        host = availableHosts[0];
        cli.activeCommand.log(`Auto-connecting only known ${deviceType}: ${host.displayName}`);
    }
    else {
        host = (await cli.activeCommand.prompt({
            type: 'list',
            name: 'host',
            message: `Which ${deviceType} do you wish to sideload to?`,
            choices: availableHosts.map((host) => ({
                name: host.displayName,
                value: host,
            })),
        })).host;
    }
    const connection = await hostConnections.connect(host, deviceType);
    connection.stream.once('close', () => cli.log(`${(0, lodash_1.startCase)(deviceType)} '${host.displayName}' disconnected`));
    return true;
};
exports.connectAction = connectAction;
function default_1(stores) {
    return (cli) => {
        const deviceTypes = ['device', 'phone'];
        for (const deviceType of deviceTypes) {
            cli
                .command(`connect ${deviceType}`, `Connect a ${deviceType}`)
                .action(async () => (0, exports.connectAction)(cli, deviceType, stores.hostConnections));
        }
    };
}
exports.default = default_1;
//# sourceMappingURL=connect.js.map